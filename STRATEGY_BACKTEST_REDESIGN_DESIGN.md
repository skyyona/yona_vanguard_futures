# ğŸ¯ ì „ëµ ë°±í…ŒìŠ¤íŒ… ê¸°ëŠ¥ ì¬ì„¤ê³„ ì„¤ê³„ ë³´ê³ ì„œ

**ì„¤ê³„ ì¼ì‹œ**: 2025-11-20  
**ì‘ì—… ìƒíƒœ**: ì„¤ê³„ ì™„ë£Œ (êµ¬í˜„ ëŒ€ê¸°)  
**ëª©ì **: ë°±í…ŒìŠ¤íŒ… ê¸°ëŠ¥ì„ ì „ëµ ë¶„ì„ ê¸°ë°˜ ìë™ë§¤ë§¤ ì‹œìŠ¤í…œìœ¼ë¡œ ì¬ì„¤ê³„

---

## ğŸ“‹ ìš”êµ¬ì‚¬í•­ ì •ë¦¬

### 1. íƒ€ì´í‹€ ë³€ê²½
- **ê¸°ì¡´**: "ê±°ë˜ ì í•©ì„±"
- **ë³€ê²½**: "ì „ëµ ë°±í…ŒìŠ¤íŒ…"
- **ìœ„ì¹˜**: ì¤‘ë‹¨ ì„¸ì…˜ 1ì—´ 'Real-time Ranking List'ì˜ 2ë²ˆì§¸ ì»¬ëŸ¼

### 2. ì „ëµ ë¶„ì„ ë²„íŠ¼ ì¶”ê°€
- **ìœ„ì¹˜**: ê° ì½”ì¸ ì‹¬ë³¼ í–‰ì˜ "ì „ëµ ë°±í…ŒìŠ¤íŒ…" ì»¬ëŸ¼ì— ë²„íŠ¼ ì¶”ê°€
- **ë²„íŠ¼ í…ìŠ¤íŠ¸**: "ì „ëµ ë¶„ì„"
- **ê¸°ëŠ¥**: í´ë¦­ ì‹œ í•´ë‹¹ ì½”ì¸ ì‹¬ë³¼ì— ëŒ€í•œ ì „ëµ ë¶„ì„ ì‹¤í–‰

### 3. ì „ëµ ë¶„ì„ ê¸°ëŠ¥
- ìš°ë¦¬ ì•± ì—”ì§„ì— êµ¬í˜„ëœ ì „ëµ ì§€í‘œ ì‚¬ìš©
- 3ê°œ ì—”ì§„ (Alpha, Beta, Gamma) ê°ê°ì— ëŒ€í•œ ë°±í…ŒìŠ¤íŒ…
- ê°€ì¥ ì í•©í•œ ì „ëµ ìë™ ì„ íƒ
- ë³€ë™ì„± ê¸°ë°˜ ìµœëŒ€ ëª©í‘œ ìˆ˜ìµë¥ % ê³„ì‚°
- ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì •ë³´ í¬í•¨

### 4. íŒì—…ì°½ í‘œì‹œ
- ë¶„ì„ ê²°ê³¼ë¥¼ íŒì—…ì°½ì— í‘œì‹œ
- í‘œì‹œ ë‚´ìš©:
  - ì ìš©í•  ì „ëµ (Alpha/Beta/Gamma)
  - ë³€ë™ì„±ì— ë”°ë¥¸ ìµœëŒ€ ëª©í‘œ ìˆ˜ìµë¥ %
  - ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì •ë³´
  - ì—”ì§„ë³„ ë°±í…ŒìŠ¤íŠ¸ ê²°ê³¼ ìš”ì•½

### 5. íŒì—…ì°½ í•˜ë‹¨ ë²„íŠ¼
- **ìœ„ì¹˜**: íŒì—…ì°½ í•˜ë‹¨
- **ë²„íŠ¼**: [ì•ŒíŒŒ], [ë² íƒ€], [ê°ë§ˆ]
- **ê¸°ëŠ¥**: ì„ íƒí•œ ì—”ì§„ì— ì „ëµ ë°°ì¹˜

### 6. ì „ëµ ì—…ë°ì´íŠ¸
- ì—”ì§„ ë°°ì¹˜ ë²„íŠ¼ í´ë¦­ ì‹œ í•´ë‹¹ ì—”ì§„ì˜ ì „ëµ ì—…ë°ì´íŠ¸
- ë°±í…ŒìŠ¤íŒ… ë¶„ì„ ê²°ê³¼ë¥¼ ì—”ì§„ ì„¤ì •ì— ë°˜ì˜

### 7. ì—”ì§„ ì„¤ì •
- **Designated Funds**: íˆ¬ì… ìê¸ˆ ë¹„ìœ¨ ì„¤ì •
- **Applied Leverage**: ë ˆë²„ë¦¬ì§€ ì„¤ì •
- **ì„¤ì • ì ìš©** ë²„íŠ¼: ë°”ì´ë‚¸ìŠ¤ APIë¡œ ì„¤ì • ì ìš©

### 8. ê±°ë˜ í™œì„±í™”
- **ê±°ë˜ í™œì„±í™”** ë²„íŠ¼: ì‹¤ì œ ìë™ë§¤ë§¤ ê±°ë˜ ì‹œì‘

---

## ğŸ¯ ê¸°ëŠ¥ ì„¤ê³„

### 1. GUI ë³€ê²½ì‚¬í•­

#### 1.1 ë­í‚¹ í…Œì´ë¸” í—¤ë” ë³€ê²½

**íŒŒì¼**: `gui/widgets/ranking_table_widget.py`

**ë³€ê²½ ë‚´ìš©:**
```python
# Line 28
# ê¸°ì¡´
self.setHorizontalHeaderLabels(["ì„ íƒ", "ê±°ë˜ ì í•©ì„±", "ì½”ì¸ ì‹¬ë³¼", "ìƒìŠ¹ë¥ %", "ëˆ„ì ", "ìƒìŠ¹ ìœ í˜•"])

# ë³€ê²½ í›„
self.setHorizontalHeaderLabels(["ì„ íƒ", "ì „ëµ ë°±í…ŒìŠ¤íŒ…", "ì½”ì¸ ì‹¬ë³¼", "ìƒìŠ¹ë¥ %", "ëˆ„ì ", "ìƒìŠ¹ ìœ í˜•"])
```

#### 1.2 ì „ëµ ë¶„ì„ ë²„íŠ¼ ì¶”ê°€

**íŒŒì¼**: `gui/widgets/ranking_table_widget.py`

**ë³€ê²½ ë‚´ìš©:**
```python
# Line 117-146 ìˆ˜ì •
# ê¸°ì¡´: í…ìŠ¤íŠ¸ ì•„ì´í…œ í‘œì‹œ
# ë³€ê²½ í›„: ë²„íŠ¼ ìœ„ì ¯ í‘œì‹œ

def _create_strategy_analysis_button(self, symbol: str, status: str, score: float) -> QPushButton:
    """ì „ëµ ë¶„ì„ ë²„íŠ¼ ìƒì„±"""
    button = QPushButton("ì „ëµ ë¶„ì„")
    button.setProperty("symbol", symbol)
    button.setProperty("status", status)
    button.setProperty("score", score)
    
    # ë²„íŠ¼ ìŠ¤íƒ€ì¼
    button.setStyleSheet("""
        QPushButton {
            background-color: #4CAF50;
            color: white;
            font-weight: bold;
            font-size: 9px;
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            min-width: 60px;
        }
        QPushButton:hover {
            background-color: #66BB6A;
        }
        QPushButton:pressed {
            background-color: #388E3C;
        }
    """)
    
    # í´ë¦­ ì´ë²¤íŠ¸ ì—°ê²°
    button.clicked.connect(lambda: self._on_strategy_analysis_clicked(symbol))
    
    return button

def _on_strategy_analysis_clicked(self, symbol: str):
    """ì „ëµ ë¶„ì„ ë²„íŠ¼ í´ë¦­"""
    self.strategy_analysis_requested.emit(symbol)

# Signal ì¶”ê°€
strategy_analysis_requested = Signal(str)  # ì „ëµ ë¶„ì„ ìš”ì²­ ì‹œ
```

**í…Œì´ë¸” populate ë©”ì„œë“œ ìˆ˜ì •:**
```python
# Line 117-146 ìˆ˜ì •
# ê¸°ì¡´
suitability_item = QTableWidgetItem(text)
self.setItem(i, 1, suitability_item)

# ë³€ê²½ í›„
# ë²„íŠ¼ ìœ„ì ¯ìœ¼ë¡œ ë³€ê²½
button = self._create_strategy_analysis_button(symbol, status, score)
button_widget = QWidget()
button_layout = QHBoxLayout(button_widget)
button_layout.addWidget(button)
button_layout.setAlignment(Qt.AlignCenter)
button_layout.setContentsMargins(0, 0, 0, 0)
self.setCellWidget(i, 1, button_widget)
```

### 2. ì „ëµ ë¶„ì„ ê¸°ëŠ¥

#### 2.1 ë°±ì—”ë“œ API

**ìƒˆë¡œìš´ ì—”ë“œí¬ì¸íŠ¸**: `GET /api/v1/backtest/strategy-analysis`

**íŒŒì¼**: `backend/api/routes.py`

**êµ¬í˜„ ë‚´ìš©:**
```python
@router.get("/backtest/strategy-analysis")
async def get_strategy_analysis(
    symbol: str,
    period: str = "1w"
):
    """
    ì½”ì¸ ì‹¬ë³¼ì— ëŒ€í•œ ì „ëµ ë¶„ì„ (3ê°œ ì—”ì§„ë³„ ë°±í…ŒìŠ¤íŒ…)
    
    Args:
        symbol: ì½”ì¸ ì‹¬ë³¼ (ì˜ˆ: "BTCUSDT")
        period: ë°±í…ŒìŠ¤íŠ¸ ê¸°ê°„ ("1w" or "1m")
    
    Returns:
        {
            "success": true,
            "data": {
                "symbol": "BTCUSDT",
                "best_engine": "Alpha",  # ê°€ì¥ ì í•©í•œ ì—”ì§„
                "volatility": 2.5,  # ë³€ë™ì„± (%)
                "max_target_profit": {
                    "alpha": 3.7,  # Alpha ìµœëŒ€ ëª©í‘œ ìˆ˜ìµë¥ %
                    "beta": 5.0,   # Beta ìµœëŒ€ ëª©í‘œ ìˆ˜ìµë¥ %
                    "gamma": 8.5   # Gamma ìµœëŒ€ ëª©í‘œ ìˆ˜ìµë¥ %
                },
                "risk_management": {
                    "stop_loss": 0.5,  # ì†ì ˆ (%)
                    "trailing_stop": 0.3  # íŠ¸ë ˆì¼ë§ ìŠ¤í†± (%)
                },
                "engine_results": {
                    "alpha": {
                        "suitability": "ì í•©",
                        "score": 85.0,
                        "expected_profit": 3.2,
                        "win_rate": 65.0,
                        "metrics": {...}
                    },
                    "beta": {
                        "suitability": "ì£¼ì˜ í•„ìš”",
                        "score": 55.0,
                        "expected_profit": 4.5,
                        "win_rate": 50.0,
                        "metrics": {...}
                    },
                    "gamma": {
                        "suitability": "ë¶€ì í•©",
                        "score": 30.0,
                        "expected_profit": 7.0,
                        "win_rate": 35.0,
                        "metrics": {...}
                    }
                }
            }
        }
    """
    # 1. ê³µìœ  BinanceClient ê°€ì ¸ì˜¤ê¸°
    engine_manager = get_engine_manager()
    shared_binance_client = engine_manager._shared_binance_client
    
    # 2. ë³€ë™ì„± ê³„ì‚°
    volatility = await calculate_volatility(symbol, shared_binance_client)
    
    # 3. 3ê°œ ì—”ì§„ë³„ ë°±í…ŒìŠ¤íŒ… ì‹¤í–‰
    engine_results = {}
    
    for engine_name in ["Alpha", "Beta", "Gamma"]:
        # ì—”ì§„ë³„ ì „ëµ ì„¤ì •
        from backend.core.new_strategy import StrategyOrchestrator, OrchestratorConfig
        
        # ì—”ì§„ë³„ ê¸°ë³¸ ì„¤ì •
        engine_configs = {
            "Alpha": {"leverage": 5, "order_quantity": 0.001, "timeframe": "1m"},
            "Beta": {"leverage": 3, "order_quantity": 0.001, "timeframe": "5m"},
            "Gamma": {"leverage": 2, "order_quantity": 0.001, "timeframe": "1h"}
        }
        
        config = engine_configs[engine_name]
        orchestrator_config = OrchestratorConfig(
            symbol=symbol,
            leverage=config["leverage"],
            order_quantity=config["order_quantity"],
            enable_trading=False,
        )
        
        orchestrator = StrategyOrchestrator(
            binance_client=shared_binance_client,
            config=orchestrator_config
        )
        
        # ë°±í…ŒìŠ¤íŠ¸ ì‹¤í–‰
        from backend.core.new_strategy.backtest_adapter import BacktestAdapter, BacktestConfig
        
        end_date = datetime.now()
        if period == "1w":
            start_date = end_date - timedelta(days=7)
        elif period == "1m":
            start_date = end_date - timedelta(days=30)
        
        backtest_config = BacktestConfig(
            symbol=symbol,
            start_date=start_date.strftime("%Y-%m-%d"),
            end_date=end_date.strftime("%Y-%m-%d"),
            initial_balance=10000.0,
            leverage=config["leverage"],
            commission_rate=0.0004,
            slippage_rate=0.0001,
        )
        
        adapter = BacktestAdapter(shared_binance_client)
        results = adapter.run_backtest(orchestrator, backtest_config)
        
        # ì í•©ì„± í‰ê°€
        suitability, score = evaluate_suitability(results)
        
        # ë³€ë™ì„± ê¸°ë°˜ ìµœëŒ€ ëª©í‘œ ìˆ˜ìµë¥ % ê³„ì‚°
        max_target_profit = calculate_max_target_profit(
            engine_name, volatility, results
        )
        
        engine_results[engine_name.lower()] = {
            "suitability": suitability,
            "score": score,
            "expected_profit": results.get("total_pnl_pct", 0),
            "win_rate": results.get("win_rate", 0),
            "metrics": results
        }
    
    # 4. ê°€ì¥ ì í•©í•œ ì—”ì§„ ì„ íƒ
    best_engine = max(
        engine_results.items(),
        key=lambda x: x[1]["score"]
    )[0].capitalize()
    
    # 5. ìµœëŒ€ ëª©í‘œ ìˆ˜ìµë¥ % ê³„ì‚° (ë³€ë™ì„± ê¸°ë°˜)
    max_target_profit = {
        "alpha": min(3.7, volatility * 1.5),  # ë³€ë™ì„±ì˜ 1.5ë°°, ìµœëŒ€ 3.7%
        "beta": min(5.0, volatility * 2.0),   # ë³€ë™ì„±ì˜ 2.0ë°°, ìµœëŒ€ 5.0%
        "gamma": min(8.5, volatility * 3.0)   # ë³€ë™ì„±ì˜ 3.0ë°°, ìµœëŒ€ 8.5%
    }
    
    # 6. ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì •ë³´
    risk_management = {
        "stop_loss": 0.5,      # ì†ì ˆ 0.5% (ëª¨ë“  ì—”ì§„ ê³µí†µ)
        "trailing_stop": 0.3   # íŠ¸ë ˆì¼ë§ ìŠ¤í†± 0.3% (ëª¨ë“  ì—”ì§„ ê³µí†µ)
    }
    
    return {
        "success": True,
        "data": {
            "symbol": symbol,
            "best_engine": best_engine,
            "volatility": volatility,
            "max_target_profit": max_target_profit,
            "risk_management": risk_management,
            "engine_results": engine_results
        }
    }
```

#### 2.2 ë³€ë™ì„± ê³„ì‚° í•¨ìˆ˜

**êµ¬í˜„ ë‚´ìš©:**
```python
async def calculate_volatility(symbol: str, binance_client) -> float:
    """
    ì½”ì¸ì˜ ë³€ë™ì„± ê³„ì‚° (24ì‹œê°„ ê¸°ì¤€)
    
    Returns:
        ë³€ë™ì„± (%)
    """
    # 24ì‹œê°„ í‹°ì»¤ ë°ì´í„° ì¡°íšŒ
    ticker = binance_client.get_24hr_ticker(symbol)
    
    if "error" in ticker:
        return 0.0
    
    # ë³€ë™ì„± ê³„ì‚°: (ê³ ê°€ - ì €ê°€) / í˜„ì¬ê°€ * 100
    high_price = float(ticker.get("highPrice", 0))
    low_price = float(ticker.get("lowPrice", 0))
    current_price = float(ticker.get("lastPrice", 0))
    
    if current_price == 0:
        return 0.0
    
    volatility = ((high_price - low_price) / current_price) * 100
    return round(volatility, 2)
```

#### 2.3 ìµœëŒ€ ëª©í‘œ ìˆ˜ìµë¥ % ê³„ì‚° í•¨ìˆ˜

**êµ¬í˜„ ë‚´ìš©:**
```python
def calculate_max_target_profit(
    engine_name: str,
    volatility: float,
    backtest_results: Dict[str, Any]
) -> float:
    """
    ë³€ë™ì„± ê¸°ë°˜ ìµœëŒ€ ëª©í‘œ ìˆ˜ìµë¥ % ê³„ì‚°
    
    Args:
        engine_name: ì—”ì§„ëª… ("Alpha", "Beta", "Gamma")
        volatility: ë³€ë™ì„± (%)
        backtest_results: ë°±í…ŒìŠ¤íŠ¸ ê²°ê³¼
    
    Returns:
        ìµœëŒ€ ëª©í‘œ ìˆ˜ìµë¥ %
    """
    # ì—”ì§„ë³„ ê¸°ë³¸ ìµì ˆë¥ 
    base_profit = {
        "Alpha": 3.7,
        "Beta": 5.0,
        "Gamma": 8.5
    }
    
    # ë³€ë™ì„± ê¸°ë°˜ ì¡°ì •
    volatility_multiplier = {
        "Alpha": 1.5,  # ë³€ë™ì„±ì˜ 1.5ë°°
        "Beta": 2.0,   # ë³€ë™ì„±ì˜ 2.0ë°°
        "Gamma": 3.0   # ë³€ë™ì„±ì˜ 3.0ë°°
    }
    
    base = base_profit.get(engine_name, 3.7)
    multiplier = volatility_multiplier.get(engine_name, 1.5)
    
    # ë³€ë™ì„± ê¸°ë°˜ ê³„ì‚° (ìµœëŒ€ ê¸°ë³¸ ìµì ˆë¥  ì œí•œ)
    volatility_based = volatility * multiplier
    max_profit = min(base, volatility_based)
    
    # ë°±í…ŒìŠ¤íŠ¸ ê²°ê³¼ ë°˜ì˜ (ì˜ˆìƒ ìˆ˜ìµë¥ ì˜ 80%ë¥¼ ì•ˆì „ ë§ˆì§„ìœ¼ë¡œ ì„¤ì •)
    expected_profit = backtest_results.get("total_pnl_pct", 0)
    if expected_profit > 0:
        max_profit = min(max_profit, expected_profit * 0.8)
    
    return round(max_profit, 2)
```

### 3. íŒì—…ì°½ êµ¬í˜„

#### 3.1 íŒì—…ì°½ ìœ„ì ¯

**ìƒˆ íŒŒì¼**: `gui/widgets/strategy_analysis_dialog.py`

**êµ¬í˜„ ë‚´ìš©:**
```python
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QLabel,
    QPushButton, QTextEdit, QScrollArea, QWidget
)
from PySide6.QtCore import Qt
from PySide6.QtGui import QFont, QColor

class StrategyAnalysisDialog(QDialog):
    """ì „ëµ ë¶„ì„ ê²°ê³¼ íŒì—…ì°½"""
    
    # Signal ì •ì˜
    engine_assigned = Signal(str, dict)  # ì—”ì§„ ë°°ì¹˜ ì‹œ (engine_name, strategy_data)
    
    def __init__(self, symbol: str, analysis_data: dict, parent=None):
        super().__init__(parent)
        self.symbol = symbol
        self.analysis_data = analysis_data
        
        self.setWindowTitle(f"ì „ëµ ë¶„ì„ ê²°ê³¼ - {symbol}")
        self.setMinimumWidth(600)
        self.setMinimumHeight(700)
        
        self._init_ui()
    
    def _init_ui(self):
        layout = QVBoxLayout(self)
        layout.setSpacing(10)
        layout.setContentsMargins(15, 15, 15, 15)
        
        # 1. í—¤ë”
        header = QLabel(f"ì „ëµ ë¶„ì„ ê²°ê³¼: {self.symbol}")
        header_font = QFont()
        header_font.setBold(True)
        header_font.setPointSize(14)
        header.setFont(header_font)
        layout.addWidget(header)
        
        # 2. ì¶”ì²œ ì—”ì§„
        best_engine = self.analysis_data.get("best_engine", "Alpha")
        recommendation = QLabel(f"âœ… ì¶”ì²œ ì—”ì§„: {best_engine}")
        recommendation.setStyleSheet("color: #4CAF50; font-weight: bold; font-size: 12px;")
        layout.addWidget(recommendation)
        
        # 3. ë³€ë™ì„± ì •ë³´
        volatility = self.analysis_data.get("volatility", 0)
        volatility_label = QLabel(f"ğŸ“Š ë³€ë™ì„±: {volatility:.2f}%")
        volatility_label.setStyleSheet("color: #FFC107; font-size: 11px;")
        layout.addWidget(volatility_label)
        
        # 4. ìŠ¤í¬ë¡¤ ì˜ì—­ (ìƒì„¸ ì •ë³´)
        scroll_area = QScrollArea()
        scroll_widget = QWidget()
        scroll_layout = QVBoxLayout(scroll_widget)
        
        # 4-1. ìµœëŒ€ ëª©í‘œ ìˆ˜ìµë¥ %
        max_profit = self.analysis_data.get("max_target_profit", {})
        profit_section = self._create_section(
            "ğŸ¯ ìµœëŒ€ ëª©í‘œ ìˆ˜ìµë¥ %",
            f"Alpha: {max_profit.get('alpha', 0):.2f}%\n"
            f"Beta: {max_profit.get('beta', 0):.2f}%\n"
            f"Gamma: {max_profit.get('gamma', 0):.2f}%"
        )
        scroll_layout.addWidget(profit_section)
        
        # 4-2. ë¦¬ìŠ¤í¬ ê´€ë¦¬
        risk_mgmt = self.analysis_data.get("risk_management", {})
        risk_section = self._create_section(
            "âš ï¸ ë¦¬ìŠ¤í¬ ê´€ë¦¬",
            f"ì†ì ˆ: {risk_mgmt.get('stop_loss', 0):.2f}%\n"
            f"íŠ¸ë ˆì¼ë§ ìŠ¤í†±: {risk_mgmt.get('trailing_stop', 0):.2f}%"
        )
        scroll_layout.addWidget(risk_section)
        
        # 4-3. ì—”ì§„ë³„ ìƒì„¸ ê²°ê³¼
        engine_results = self.analysis_data.get("engine_results", {})
        for engine_name in ["alpha", "beta", "gamma"]:
            engine_data = engine_results.get(engine_name, {})
            engine_section = self._create_engine_section(engine_name, engine_data)
            scroll_layout.addWidget(engine_section)
        
        scroll_layout.addStretch()
        scroll_area.setWidget(scroll_widget)
        scroll_area.setWidgetResizable(True)
        layout.addWidget(scroll_area)
        
        # 5. ì—”ì§„ ë°°ì¹˜ ë²„íŠ¼ (í•˜ë‹¨)
        button_layout = QHBoxLayout()
        button_layout.setSpacing(10)
        
        # ì—”ì§„ë³„ ë²„íŠ¼
        engines = [
            ("Alpha", "#4CAF50", "[ì•ŒíŒŒ]"),
            ("Beta", "#2196F3", "[ë² íƒ€]"),
            ("Gamma", "#FF9800", "[ê°ë§ˆ]")
        ]
        
        for engine_name, color, label in engines:
            btn = QPushButton(label)
            btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: {color};
                    color: white;
                    font-weight: bold;
                    font-size: 11px;
                    border: none;
                    border-radius: 4px;
                    padding: 8px 20px;
                    min-width: 80px;
                }}
                QPushButton:hover {{
                    background-color: {self._lighten_color(color)};
                }}
            """)
            
            # í´ë¦­ ì´ë²¤íŠ¸
            btn.clicked.connect(
                lambda checked, e=engine_name: self._on_engine_assigned(e)
            )
            
            button_layout.addWidget(btn)
        
        layout.addLayout(button_layout)
    
    def _create_section(self, title: str, content: str) -> QWidget:
        """ì„¹ì…˜ ìœ„ì ¯ ìƒì„±"""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(0, 0, 0, 0)
        
        title_label = QLabel(title)
        title_label.setStyleSheet("font-weight: bold; font-size: 11px; color: #FFC107;")
        layout.addWidget(title_label)
        
        content_label = QLabel(content)
        content_label.setStyleSheet("font-size: 10px; color: #CCCCCC;")
        content_label.setWordWrap(True)
        layout.addWidget(content_label)
        
        return widget
    
    def _create_engine_section(self, engine_name: str, engine_data: dict) -> QWidget:
        """ì—”ì§„ë³„ ìƒì„¸ ê²°ê³¼ ì„¹ì…˜"""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(0, 0, 0, 0)
        
        suitability = engine_data.get("suitability", "ë¶€ì í•©")
        score = engine_data.get("score", 0)
        expected_profit = engine_data.get("expected_profit", 0)
        win_rate = engine_data.get("win_rate", 0)
        
        title = f"ğŸ”§ {engine_name.upper()} ì—”ì§„"
        content = (
            f"ì í•©ì„±: {suitability} ({score:.0f}ì )\n"
            f"ì˜ˆìƒ ìˆ˜ìµë¥ : {expected_profit:.2f}%\n"
            f"ìŠ¹ë¥ : {win_rate:.1f}%"
        )
        
        title_label = QLabel(title)
        title_label.setStyleSheet("font-weight: bold; font-size: 11px; color: #2196F3;")
        layout.addWidget(title_label)
        
        content_label = QLabel(content)
        content_label.setStyleSheet("font-size: 10px; color: #CCCCCC;")
        layout.addWidget(content_label)
        
        return widget
    
    def _on_engine_assigned(self, engine_name: str):
        """ì—”ì§„ ë°°ì¹˜ ë²„íŠ¼ í´ë¦­"""
        # ì „ëµ ë°ì´í„° ì¤€ë¹„
        strategy_data = {
            "symbol": self.symbol,
            "engine_name": engine_name,
            "analysis_data": self.analysis_data
        }
        
        # Signal ë°œì†¡
        self.engine_assigned.emit(engine_name, strategy_data)
        
        # íŒì—…ì°½ ë‹«ê¸°
        self.accept()
```

### 4. ì „ëµ ì—…ë°ì´íŠ¸ ê¸°ëŠ¥

#### 4.1 ì—”ì§„ ì „ëµ ì—…ë°ì´íŠ¸

**íŒŒì¼**: `gui/main.py`

**êµ¬í˜„ ë‚´ìš©:**
```python
def _on_strategy_engine_assigned(self, engine_name: str, strategy_data: dict):
    """ì „ëµ ë¶„ì„ í›„ ì—”ì§„ ë°°ì¹˜"""
    symbol = strategy_data.get("symbol")
    analysis_data = strategy_data.get("analysis_data", {})
    
    # ì—”ì§„ë³„ ì „ëµ ì„¤ì • ì¶”ì¶œ
    engine_results = analysis_data.get("engine_results", {})
    engine_key = engine_name.lower()
    engine_result = engine_results.get(engine_key, {})
    
    # ìµœëŒ€ ëª©í‘œ ìˆ˜ìµë¥ %
    max_profit = analysis_data.get("max_target_profit", {}).get(engine_key, 0)
    
    # ë¦¬ìŠ¤í¬ ê´€ë¦¬
    risk_mgmt = analysis_data.get("risk_management", {})
    
    # ì—”ì§„ì— ì „ëµ ì„¤ì • ì ìš©
    # 1. ì‹¬ë³¼ ì„¤ì •
    # 2. ë ˆë²„ë¦¬ì§€ ì„¤ì • (ì—”ì§„ë³„ ê¸°ë³¸ê°’)
    # 3. ìµì ˆ/ì†ì ˆ ì„¤ì • (ë¶„ì„ ê²°ê³¼ ê¸°ë°˜)
    
    # í•˜ë‹¨ í‘¸í„°ì˜ í•´ë‹¹ ì—”ì§„ì— ì „ë‹¬
    if engine_name == "Alpha":
        self.footer_widget.alpha_engine.update_strategy_from_analysis(
            symbol, max_profit, risk_mgmt
        )
    elif engine_name == "Beta":
        self.footer_widget.beta_engine.update_strategy_from_analysis(
            symbol, max_profit, risk_mgmt
        )
    elif engine_name == "Gamma":
        self.footer_widget.gamma_engine.update_strategy_from_analysis(
            symbol, max_profit, risk_mgmt
        )
```

#### 4.2 ì—”ì§„ ìœ„ì ¯ ì „ëµ ì—…ë°ì´íŠ¸ ë©”ì„œë“œ

**íŒŒì¼**: `gui/widgets/footer_engines_widget.py`

**êµ¬í˜„ ë‚´ìš©:**
```python
def update_strategy_from_analysis(
    self,
    symbol: str,
    max_target_profit: float,
    risk_management: dict
):
    """ì „ëµ ë¶„ì„ ê²°ê³¼ë¡œ ì—”ì§„ ì„¤ì • ì—…ë°ì´íŠ¸"""
    # 1. ì‹¬ë³¼ ì„¤ì •
    self.selected_symbol = symbol
    self.symbol_label.setText(symbol)
    
    # 2. ìµì ˆë¥  ì—…ë°ì´íŠ¸ (ìµœëŒ€ ëª©í‘œ ìˆ˜ìµë¥ % ê¸°ë°˜)
    # ì—”ì§„ë³„ ê¸°ë³¸ ìµì ˆë¥  ê°€ì ¸ì˜¤ê¸°
    base_profit = {
        "Alpha": 3.7,
        "Beta": 5.0,
        "Gamma": 8.5
    }
    
    # ë¶„ì„ ê²°ê³¼ì˜ ìµœëŒ€ ëª©í‘œ ìˆ˜ìµë¥ %ì™€ ê¸°ë³¸ê°’ ì¤‘ ì‘ì€ ê°’ ì‚¬ìš©
    target_profit = min(
        max_target_profit,
        base_profit.get(self.engine_name, 3.7)
    )
    
    # 3. ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì—…ë°ì´íŠ¸
    stop_loss = risk_management.get("stop_loss", 0.5)
    trailing_stop = risk_management.get("trailing_stop", 0.3)
    
    # ì—”ì§„ ì„¤ì • ì—…ë°ì´íŠ¸ (Orchestratorì— ë°˜ì˜)
    if hasattr(self, 'orchestrator') and self.orchestrator:
        # Orchestrator ì„¤ì • ì—…ë°ì´íŠ¸
        self.orchestrator.cfg.symbol = symbol
        # ìµì ˆ/ì†ì ˆ ì„¤ì • ì—…ë°ì´íŠ¸ (Orchestrator ë‚´ë¶€ ì „ëµì— ë°˜ì˜ í•„ìš”)
        # ì´ ë¶€ë¶„ì€ Orchestrator êµ¬ì¡°ì— ë”°ë¼ êµ¬í˜„ í•„ìš”
```

### 5. ë°±ì—”ë“œ ì „ëµ ì—…ë°ì´íŠ¸ API

**ìƒˆë¡œìš´ ì—”ë“œí¬ì¸íŠ¸**: `POST /api/v1/engine/update-strategy`

**íŒŒì¼**: `backend/api/routes.py`

**êµ¬í˜„ ë‚´ìš©:**
```python
class UpdateStrategyRequest(BaseModel):
    engine: str  # "Alpha", "Beta", "Gamma"
    symbol: str
    max_target_profit: float
    stop_loss: float
    trailing_stop: float
    leverage: int
    order_quantity: float

@router.post("/engine/update-strategy")
async def update_engine_strategy(request: UpdateStrategyRequest):
    """
    ì—”ì§„ ì „ëµ ì„¤ì • ì—…ë°ì´íŠ¸
    
    Args:
        engine: ì—”ì§„ëª…
        symbol: ì½”ì¸ ì‹¬ë³¼
        max_target_profit: ìµœëŒ€ ëª©í‘œ ìˆ˜ìµë¥ %
        stop_loss: ì†ì ˆ%
        trailing_stop: íŠ¸ë ˆì¼ë§ ìŠ¤í†±%
        leverage: ë ˆë²„ë¦¬ì§€
        order_quantity: ì£¼ë¬¸ ìˆ˜ëŸ‰
    
    Returns:
        {"status": "success", "message": "..."}
    """
    engine_manager = get_engine_manager()
    
    if request.engine not in ["Alpha", "Beta", "Gamma"]:
        raise HTTPException(status_code=400, detail="Invalid engine name")
    
    engine = engine_manager.engines.get(request.engine)
    if not engine:
        raise HTTPException(status_code=404, detail="Engine not found")
    
    # ì—”ì§„ ì„¤ì • ì—…ë°ì´íŠ¸
    if hasattr(engine, 'orchestrator') and engine.orchestrator:
        # Orchestrator ì„¤ì • ì—…ë°ì´íŠ¸
        engine.orchestrator.cfg.symbol = request.symbol
        engine.orchestrator.cfg.leverage = request.leverage
        engine.orchestrator.cfg.order_quantity = request.order_quantity
        
        # ì „ëµ íŒŒë¼ë¯¸í„° ì—…ë°ì´íŠ¸ (Orchestrator ë‚´ë¶€ ì „ëµì— ë°˜ì˜)
        # ì´ ë¶€ë¶„ì€ Orchestrator êµ¬ì¡°ì— ë”°ë¼ êµ¬í˜„ í•„ìš”
    
    return {
        "status": "success",
        "message": f"{request.engine} ì—”ì§„ ì „ëµì´ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤."
    }
```

---

## ğŸ“‹ íŒŒì¼ ë³€ê²½ ëª©ë¡

### 1. GUI íŒŒì¼

#### 1.1 ìˆ˜ì • íŒŒì¼
- `gui/widgets/ranking_table_widget.py`
  - í—¤ë” ë ˆì´ë¸” ë³€ê²½: "ê±°ë˜ ì í•©ì„±" â†’ "ì „ëµ ë°±í…ŒìŠ¤íŒ…"
  - ì»¬ëŸ¼ 1ì„ í…ìŠ¤íŠ¸ ì•„ì´í…œì—ì„œ ë²„íŠ¼ ìœ„ì ¯ìœ¼ë¡œ ë³€ê²½
  - "ì „ëµ ë¶„ì„" ë²„íŠ¼ ì¶”ê°€
  - Signal ì¶”ê°€: `strategy_analysis_requested`

- `gui/main.py`
  - ì „ëµ ë¶„ì„ ìš”ì²­ í•¸ë“¤ëŸ¬ ì¶”ê°€: `_on_strategy_analysis_requested`
  - íŒì—…ì°½ í‘œì‹œ ë¡œì§ ì¶”ê°€
  - ì—”ì§„ ë°°ì¹˜ í•¸ë“¤ëŸ¬ ìˆ˜ì •: `_on_strategy_engine_assigned`
  - Signal ì—°ê²° ì¶”ê°€

#### 1.2 ì‹ ê·œ íŒŒì¼
- `gui/widgets/strategy_analysis_dialog.py`
  - ì „ëµ ë¶„ì„ ê²°ê³¼ íŒì—…ì°½ ìœ„ì ¯

### 2. ë°±ì—”ë“œ íŒŒì¼

#### 2.1 ìˆ˜ì • íŒŒì¼
- `backend/api/routes.py`
  - ìƒˆë¡œìš´ ì—”ë“œí¬ì¸íŠ¸ ì¶”ê°€: `/backtest/strategy-analysis`
  - ìƒˆë¡œìš´ ì—”ë“œí¬ì¸íŠ¸ ì¶”ê°€: `/engine/update-strategy`
  - ë³€ë™ì„± ê³„ì‚° í•¨ìˆ˜ ì¶”ê°€
  - ìµœëŒ€ ëª©í‘œ ìˆ˜ìµë¥ % ê³„ì‚° í•¨ìˆ˜ ì¶”ê°€

---

## ğŸ”„ ì‘ì—… íë¦„

### 1. ì‚¬ìš©ì ì‘ì—… íë¦„

```
1. ë­í‚¹ í…Œì´ë¸”ì—ì„œ ì½”ì¸ í™•ì¸
   â†“
2. "ì „ëµ ë¶„ì„" ë²„íŠ¼ í´ë¦­
   â†“
3. íŒì—…ì°½ í‘œì‹œ (ë¶„ì„ ì§„í–‰ ì¤‘ í‘œì‹œ)
   â†“
4. ë¶„ì„ ì™„ë£Œ â†’ ê²°ê³¼ í‘œì‹œ
   - ì¶”ì²œ ì—”ì§„
   - ë³€ë™ì„±
   - ìµœëŒ€ ëª©í‘œ ìˆ˜ìµë¥ %
   - ë¦¬ìŠ¤í¬ ê´€ë¦¬
   - ì—”ì§„ë³„ ìƒì„¸ ê²°ê³¼
   â†“
5. [ì•ŒíŒŒ]/[ë² íƒ€]/[ê°ë§ˆ] ë²„íŠ¼ ì¤‘ ì„ íƒ
   â†“
6. ì„ íƒí•œ ì—”ì§„ì˜ ì „ëµ ì—…ë°ì´íŠ¸
   â†“
7. í•˜ë‹¨ í‘¸í„°ì˜ í•´ë‹¹ ì—”ì§„ì—ì„œ:
   - Designated Funds ì„¤ì •
   - Applied Leverage ì„¤ì •
   â†“
8. "ì„¤ì • ì ìš©" ë²„íŠ¼ í´ë¦­
   - ë°”ì´ë‚¸ìŠ¤ APIë¡œ ë ˆë²„ë¦¬ì§€ ì„¤ì •
   â†“
9. "ê±°ë˜ í™œì„±í™”" ë²„íŠ¼ í´ë¦­
   - ì‹¤ì œ ìë™ë§¤ë§¤ ê±°ë˜ ì‹œì‘
```

### 2. ì‹œìŠ¤í…œ ì‘ì—… íë¦„

```
1. GUI: "ì „ëµ ë¶„ì„" ë²„íŠ¼ í´ë¦­
   â†“
2. API: GET /api/v1/backtest/strategy-analysis
   â†“
3. ë°±ì—”ë“œ:
   - ë³€ë™ì„± ê³„ì‚°
   - 3ê°œ ì—”ì§„ë³„ ë°±í…ŒìŠ¤íŒ… ì‹¤í–‰
   - ì í•©ì„± í‰ê°€
   - ìµœëŒ€ ëª©í‘œ ìˆ˜ìµë¥ % ê³„ì‚°
   - ê°€ì¥ ì í•©í•œ ì—”ì§„ ì„ íƒ
   â†“
4. ì‘ë‹µ ë°˜í™˜
   â†“
5. GUI: íŒì—…ì°½ì— ê²°ê³¼ í‘œì‹œ
   â†“
6. ì‚¬ìš©ì: ì—”ì§„ ì„ íƒ
   â†“
7. GUI: ì—”ì§„ì— ì „ëµ ë°°ì¹˜
   â†“
8. API: POST /api/v1/engine/update-strategy
   â†“
9. ë°±ì—”ë“œ: ì—”ì§„ ì„¤ì • ì—…ë°ì´íŠ¸
   â†“
10. GUI: í•˜ë‹¨ í‘¸í„° ì—”ì§„ ìœ„ì ¯ ì—…ë°ì´íŠ¸
```

---

## âš ï¸ ì£¼ì˜ì‚¬í•­ ë° ì œì•½ì‚¬í•­

### 1. ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­
- 3ê°œ ì—”ì§„ë³„ ë°±í…ŒìŠ¤íŒ… ì‹¤í–‰ ì‹œ ì‹œê°„ ì†Œìš” (ì•½ 10-30ì´ˆ)
- ì§„í–‰ ì¤‘ í‘œì‹œ í•„ìš” (ë¡œë”© ì¸ë””ì¼€ì´í„°)
- íƒ€ì„ì•„ì›ƒ ì„¤ì • (30ì´ˆ)

### 2. ìºì‹± ì „ëµ
- ë™ì¼ ì‹¬ë³¼ + ê¸°ê°„ ì¡°í•©ì€ ìºì‹œ í™œìš©
- ë¶„ì„ ê²°ê³¼ëŠ” ì¼ì • ì‹œê°„ ë™ì•ˆ ìœ íš¨ (ì˜ˆ: 5ë¶„)

### 3. ì˜¤ë¥˜ ì²˜ë¦¬
- ë°±í…ŒìŠ¤íŒ… ì‹¤íŒ¨ ì‹œ ì˜¤ë¥˜ ë©”ì‹œì§€ í‘œì‹œ
- API ì˜¤ë¥˜ ì‹œ ì¬ì‹œë„ ë¡œì§
- ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ì²˜ë¦¬

### 4. Orchestrator êµ¬ì¡° í™•ì¸ í•„ìš”
- Orchestrator ë‚´ë¶€ ì „ëµ íŒŒë¼ë¯¸í„° ì—…ë°ì´íŠ¸ ë°©ë²• í™•ì¸
- ìµì ˆ/ì†ì ˆ ì„¤ì • ë³€ê²½ ë°©ë²• í™•ì¸

---

## âœ… êµ¬í˜„ ì²´í¬ë¦¬ìŠ¤íŠ¸

### Phase 1: GUI ë³€ê²½
- [ ] ë­í‚¹ í…Œì´ë¸” í—¤ë” ë³€ê²½
- [ ] "ì „ëµ ë¶„ì„" ë²„íŠ¼ ì¶”ê°€
- [ ] ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸ êµ¬í˜„
- [ ] Signal ì—°ê²°

### Phase 2: ì „ëµ ë¶„ì„ API
- [ ] ë³€ë™ì„± ê³„ì‚° í•¨ìˆ˜ êµ¬í˜„
- [ ] ì—”ì§„ë³„ ë°±í…ŒìŠ¤íŒ… ì‹¤í–‰ ë¡œì§
- [ ] ìµœëŒ€ ëª©í‘œ ìˆ˜ìµë¥ % ê³„ì‚° í•¨ìˆ˜
- [ ] ê°€ì¥ ì í•©í•œ ì—”ì§„ ì„ íƒ ë¡œì§
- [ ] API ì—”ë“œí¬ì¸íŠ¸ êµ¬í˜„

### Phase 3: íŒì—…ì°½
- [ ] íŒì—…ì°½ ìœ„ì ¯ ìƒì„±
- [ ] ê²°ê³¼ í‘œì‹œ UI êµ¬í˜„
- [ ] ì—”ì§„ ë°°ì¹˜ ë²„íŠ¼ êµ¬í˜„
- [ ] Signal ì—°ê²°

### Phase 4: ì „ëµ ì—…ë°ì´íŠ¸
- [ ] ì—”ì§„ ì „ëµ ì—…ë°ì´íŠ¸ ë©”ì„œë“œ êµ¬í˜„
- [ ] ë°±ì—”ë“œ API ì—”ë“œí¬ì¸íŠ¸ êµ¬í˜„
- [ ] Orchestrator ì„¤ì • ì—…ë°ì´íŠ¸ ë¡œì§

### Phase 5: í…ŒìŠ¤íŠ¸
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
- [ ] í†µí•© í…ŒìŠ¤íŠ¸
- [ ] ì‚¬ìš©ì ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸

---

**ì„¤ê³„ ì™„ë£Œì¼**: 2025-11-20  
**ë‹¤ìŒ ë‹¨ê³„**: ì‚¬ìš©ì ìŠ¹ì¸ í›„ êµ¬í˜„ ì‘ì—… ì‹œì‘


