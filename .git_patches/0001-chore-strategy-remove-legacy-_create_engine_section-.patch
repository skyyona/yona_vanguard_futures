From dfcf49c50414e9b6a73dbbd7e5d3a3fa538b949d Mon Sep 17 00:00:00 2001
From: yona-local <local@localhost>
Date: Sat, 29 Nov 2025 05:00:16 +0900
Subject: [PATCH 1/3] chore(strategy): remove legacy _create_engine_section,
 support assign_payload executable_parameters, update headless assign test

---
 gui/main.py                             | 1160 +++++++++++++++++++++++
 gui/widgets/strategy_analysis_dialog.py |  434 +++++++++
 scripts/gui_assign_test.py              |  134 +++
 3 files changed, 1728 insertions(+)
 create mode 100644 gui/main.py
 create mode 100644 gui/widgets/strategy_analysis_dialog.py
 create mode 100644 scripts/gui_assign_test.py

diff --git a/gui/main.py b/gui/main.py
new file mode 100644
index 0000000..84c74f7
--- /dev/null
+++ b/gui/main.py
@@ -0,0 +1,1160 @@
+import sys
+import os
+import requests
+import threading
+from datetime import datetime
+from typing import Optional
+from PySide6.QtWidgets import (
+    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
+    QMessageBox, QLabel, QTabWidget, QPushButton, QSplitter
+)
+from PySide6.QtCore import Slot, Signal, Qt, QTimer
+
+# --- ê²½ë¡œ ì„¤ì • ---
+CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
+ROOT_DIR = os.path.dirname(CURRENT_DIR)
+if ROOT_DIR not in sys.path:
+    sys.path.append(ROOT_DIR)
+
+# ìœ„ì ¯ ì„í¬íŠ¸
+from gui.widgets.analysis_state import AnalysisState
+from gui.widgets.header_widget import HeaderWidget
+from gui.widgets.footer_engines_widget import MiddleSessionWidget
+from gui.widgets.ranking_table_widget import RankingTableWidget
+from gui.widgets.surge_prediction_widget import SurgePredictionWidget
+from gui.widgets.blacklist_widgets import SettlingTableWidget, BlacklistTableWidget
+from gui.widgets.position_analysis_widgets import TrendAnalysisWidget, TimingAnalysisView
+from gui.widgets.strategy_analysis_dialog import StrategyAnalysisDialog
+from utils.ws_client import WebSocketClient
+from backend.utils.logger import setup_logger # ë°±ì—”ë“œ ë¡œê±°ë¥¼ ê³µìœ 
+
+# ë°±ì—”ë“œ ì„¤ì •
+BACKEND_HOST = "127.0.0.1"
+BACKEND_PORT = 8200
+BASE_URL = f"http://{BACKEND_HOST}:{BACKEND_PORT}"
+WS_URL = f"ws://{BACKEND_HOST}:{BACKEND_PORT}/ws"
+# ë°±í…ŒìŠ¤íŒ… ì „ìš© ì—”ë“œí¬ì¸íŠ¸ (GUIê°€ ë°±í…ŒìŠ¤íŒ… ì„œë²„ë¥¼ ì§ì ‘ í˜¸ì¶œí•˜ë„ë¡ í•¨)
+BACKTEST_BASE_URL = "http://127.0.0.1:8001"
+
+class YONAMainWindow(QMainWindow):
+    # Signal ì„ ì–¸ (ìŠ¤ë ˆë“œ ì•ˆì „í•œ í†µì‹ ìš©)
+    blacklist_data_received = Signal(list)
+    analysis_ready = Signal(object)  # ë¶„ì„ ë°ì´í„° ìˆ˜ì‹  ì‹œê·¸ë„
+    backtest_completed = Signal(str, str, float, dict)  # symbol, suitability, score, metrics
+    backtest_failed = Signal(str, str)  # symbol, error
+    strategy_engine_assigned = Signal(str, dict)  # ì—”ì§„ ë°°ì¹˜ ì‹œ (engine_name, strategy_data)
+    
+    def __init__(self):
+        super().__init__()
+        self.logger = setup_logger()
+        self.setWindowTitle("YONA Vanguard Futures (new)")
+        self.setGeometry(100, 100, 1400, 900)
+
+        # ë¶„ì„ ê´€ë ¨ ë³€ìˆ˜
+        self.selected_symbol = ""
+        self._analysis_inflight = False
+        self._blacklist_loading = False
+        # ì•± ì „ì²´ ì‹œì‘ ì—¬ë¶€ (START ë²„íŠ¼ í´ë¦­ ì „ì—ëŠ” ì¤‘ë‹¨ ì„¸ì…˜/í‘¸í„° ë¹„í™œì„±)
+        self._app_started = False
+        
+        # ì‹œê°„ ê³ ì • ê´€ë ¨ ë³€ìˆ˜
+        self.fixed_time: Optional[datetime] = None
+
+        self._init_ui()
+        self._init_ws_client()
+        self._init_timers()
+        
+        # Signal ì—°ê²°
+        self.blacklist_data_received.connect(self._update_blacklist_table)
+        self.analysis_ready.connect(self._apply_analysis_data)  # ë¶„ì„ ë°ì´í„° ìˆ˜ì‹  ì‹œ UI ì—…ë°ì´íŠ¸
+        self.backtest_completed.connect(self._on_backtest_completed)
+        self.backtest_failed.connect(self._on_backtest_failed)
+        self.strategy_engine_assigned.connect(self._on_strategy_engine_assigned)  # ì „ëµ ì—”ì§„ ë°°ì¹˜
+
+        self.logger.info("GUI ë©”ì¸ ìœŒë„ìš° ì´ˆê¸°í™” ì™„ë£Œ.")
+
+    def _init_ui(self):
+        """UIì˜ ê¸°ë³¸ ë ˆì´ì•„ì›ƒì„ ì„¤ì •í•©ë‹ˆë‹¤."""
+        central_widget = QWidget()
+        self.setCentralWidget(central_widget)
+        main_layout = QVBoxLayout(central_widget)
+        main_layout.setContentsMargins(0, 0, 0, 0)
+        main_layout.setSpacing(0)
+
+        # 1. í—¤ë” ìœ„ì ¯ (ìƒë‹¨ 10%)
+        self.header_widget = HeaderWidget(self)
+        main_layout.addWidget(self.header_widget, 10)
+
+        # 2. ì¤‘ì•™ ì˜ì—­ - 2ì—´ êµ¬ì¡° (ì¤‘ë‹¨ ì„¸ì…˜ 50%)
+        middle_splitter = QSplitter(Qt.Horizontal)
+        
+        # 2-1. 1ì—´ (ì¢Œì¸¡ 63%): íƒ­ ìœ„ì ¯
+        self.tab_widget = QTabWidget()
+        
+        # íƒ­ 1: Real-time Ranking List
+        ranking_tab = QWidget()
+        ranking_layout = QVBoxLayout(ranking_tab)
+        ranking_layout.setContentsMargins(5, 5, 5, 5)
+        ranking_layout.setSpacing(5)
+        # ì‹¤ì‹œê°„ ë­í‚¹ë¦¬ìŠ¤íŠ¸ ì„¹ì…˜ë§Œ ë‚¨ê¹€
+        ranking_section = QWidget()
+        ranking_section_layout = QVBoxLayout(ranking_section)
+        ranking_section_layout.setContentsMargins(0, 0, 0, 0)
+        # í—¤ë” í–‰
+        ranking_header = QHBoxLayout()
+        ranking_title = QLabel("Real-time Ranking List")
+        ranking_title.setStyleSheet("font-weight: bold; font-size: 12px; padding: 4px; color: #000000;")
+        ranking_header.addWidget(ranking_title)
+        ranking_header.addStretch()
+        
+        # ì‹œê°„ ê³ ì • UI ì¶”ê°€
+        self.fixed_time_label = QLabel("[--:--:--]")
+        self.fixed_time_label.setAlignment(Qt.AlignCenter)
+        self.fixed_time_label.setStyleSheet("font-size: 11px; padding: 4px;")
+        ranking_header.addWidget(self.fixed_time_label)
+        
+        self.time_fix_button = QPushButton("[ì‹œê°„ê³ ì •]")
+        self.time_fix_button.setStyleSheet("""
+            QPushButton { background-color: #4CAF50; color: white; font-weight: bold; padding: 4px 8px; border-radius: 4px; border: none; font-size: 11px; }
+            QPushButton:hover { background-color: #45a049; }
+            QPushButton:pressed { background-color: #3d8b40; }
+        """)
+        self.time_fix_button.clicked.connect(self._on_time_fix_clicked)
+        ranking_header.addWidget(self.time_fix_button)
+        
+        ranking_header.addStretch()
+        
+        self.add_button = QPushButton("[ì¶”ê°€]")
+        self.add_button.setStyleSheet("background-color: #e16476; color: white; font-weight: bold; padding: 4px 8px;")
+        self.add_button.clicked.connect(self._on_add_blacklist)
+        ranking_header.addWidget(self.add_button)
+        ranking_section_layout.addLayout(ranking_header)
+        # ë­í‚¹ í…Œì´ë¸”
+        self.ranking_table = RankingTableWidget(self)
+        self.ranking_table.analyze_requested.connect(self._on_analyze_symbol)
+        self.ranking_table.backtest_requested.connect(self._on_backtest_requested)  # âœ¨ ì¶”ê°€
+        self.ranking_table.strategy_analysis_requested.connect(self._on_strategy_analysis_requested)  # ì „ëµ ë¶„ì„ ìš”ì²­
+        ranking_section_layout.addWidget(self.ranking_table)
+        ranking_layout.addWidget(ranking_section)
+        # íƒ­ 2: Settling update && Blacklist
+        blacklist_tab = QWidget()
+        blacklist_layout = QVBoxLayout(blacklist_tab)
+        blacklist_layout.setContentsMargins(5, 5, 5, 5)
+        # SETTLING ì„¹ì…˜ (ìƒë‹¨ 30%)
+        settling_section = QWidget()
+        settling_section_layout = QVBoxLayout(settling_section)
+        settling_header = QHBoxLayout()
+        settling_title = QLabel("Settling update")
+        settling_title.setStyleSheet("font-weight: bold; font-size: 12px; padding: 4px; color: #000000;")
+        settling_header.addWidget(settling_title)
+        settling_header.addStretch()
+        self.add_settling_button = QPushButton("[ì¶”ê°€]")
+        self.add_settling_button.setStyleSheet("background-color: #e16476; color: white; font-weight: bold; padding: 4px 8px;")
+        self.add_settling_button.clicked.connect(self._on_add_settling_blacklist)
+        settling_header.addWidget(self.add_settling_button)
+        settling_section_layout.addLayout(settling_header)
+        self.settling_table = SettlingTableWidget(self)
+        settling_section_layout.addWidget(self.settling_table)
+        # ë¸”ë™ë¦¬ìŠ¤íŠ¸ ì„¹ì…˜ (í•˜ë‹¨ 70%)
+        blacklist_section = QWidget()
+        blacklist_section_layout = QVBoxLayout(blacklist_section)
+        blacklist_header = QHBoxLayout()
+        blacklist_title = QLabel("Blacklist")
+        blacklist_title.setStyleSheet("font-weight: bold; font-size: 12px; padding: 4px; color: #000000;")
+        blacklist_header.addWidget(blacklist_title)
+        blacklist_header.addStretch()
+        self.remove_button = QPushButton("[í•´ì§€]")
+        self.remove_button.setStyleSheet("background-color: #ff8c25; color: white; font-weight: bold; padding: 4px 8px;")
+        self.remove_button.clicked.connect(self._on_remove_blacklist)
+        blacklist_header.addWidget(self.remove_button)
+        blacklist_section_layout.addLayout(blacklist_header)
+        self.blacklist_table = BlacklistTableWidget(self)
+        blacklist_section_layout.addWidget(self.blacklist_table)
+        # ë¶„í• ê¸°ë¡œ 30:70 ë¹„ìœ¨
+        blacklist_splitter = QSplitter(Qt.Vertical)
+        blacklist_splitter.addWidget(settling_section)
+        blacklist_splitter.addWidget(blacklist_section)
+        blacklist_splitter.setStretchFactor(0, 30)
+        blacklist_splitter.setStretchFactor(1, 70)
+        blacklist_layout.addWidget(blacklist_splitter)
+        # íƒ­ ì¶”ê°€
+        self.tab_widget.addTab(ranking_tab, "Real-time Ranking List")
+        self.tab_widget.addTab(blacklist_tab, "Settling update && Blacklist")
+        self.tab_widget.currentChanged.connect(self._on_tab_changed)
+        middle_splitter.addWidget(self.tab_widget)
+        
+        # 2-2. 2ì—´ (ìš°ì¸¡ 37%): í¬ì§€ì…˜ ì§„ì… ë¶„ì„
+        right_widget = QWidget()
+        right_layout = QVBoxLayout(right_widget)
+        right_layout.setContentsMargins(5, 5, 5, 5)
+        right_layout.setSpacing(5)
+        
+        # í¬ì§€ì…˜ ì§„ì… í—¤ë”
+        entry_header = QHBoxLayout()
+        self.entry_title = QLabel("Coin Momentum & Chart - ")
+        self.entry_title.setStyleSheet("font-weight: bold; font-size: 12px;")
+        self.entry_symbol_label = QLabel("-")
+        self.entry_symbol_label.setStyleSheet("font-weight: bold; font-size: 12px; color: #FFC107;")
+        entry_header.addWidget(self.entry_title)
+        entry_header.addWidget(self.entry_symbol_label)
+        entry_header.addStretch()
+        
+        right_layout.addLayout(entry_header)
+        
+        # ì¶”ì„¸ ë¶„ì„ ìœ„ì ¯
+        self.trend_analysis = TrendAnalysisWidget(self)
+        right_layout.addWidget(self.trend_analysis)
+        
+        # íƒ€ì´ë° ë¶„ì„ ì°¨íŠ¸
+        self.analysis_view = TimingAnalysisView(self)
+        right_layout.addWidget(self.analysis_view, 1)
+        
+        middle_splitter.addWidget(right_widget)
+        
+        # 2ì—´ ë¹„ìœ¨ ì„¤ì • (63:37)
+        middle_splitter.setStretchFactor(0, 63)
+        middle_splitter.setStretchFactor(1, 37)
+        
+        main_layout.addWidget(middle_splitter, 50)
+
+        # 3. í‘¸í„° ìœ„ì ¯ (í•˜ë‹¨ 40%) - ì•ŒíŒŒ/ë² íƒ€/ê°ë§ˆ 3ê°œ ìë™ë§¤ë§¤ ì—”ì§„
+        self.middle_session_widget = MiddleSessionWidget(self)
+        main_layout.addWidget(self.middle_session_widget, 40)
+        
+        # START/STOP ë²„íŠ¼ ì‹œê·¸ë„ ì—°ê²°
+        self.header_widget.start_signal.connect(self.on_start_clicked)
+        self.header_widget.stop_signal.connect(self.on_stop_clicked)
+        # ê¸´ê¸‰ ì²­ì‚° ë²„íŠ¼ ì‹œê·¸ë„ ì—°ê²°
+        self.header_widget.emergency_liquidation_signal.connect(self.on_emergency_liquidation_clicked)
+        # Initial Investment ë²„íŠ¼
+        self.header_widget.initial_investment_reset_signal.connect(self._on_reset_initial_investment)
+        
+        # ì—”ì§„ ì‹œì‘/ì •ì§€ ì‹œê·¸ë„ ì—°ê²°
+        self.middle_session_widget.engine_start_signal.connect(self._on_engine_start)
+        self.middle_session_widget.engine_stop_signal.connect(self._on_engine_stop)
+
+    
+    def _init_ws_client(self):
+        """ë°±ì—”ë“œì™€ í†µì‹ í•  WebSocket í´ë¼ì´ì–¸íŠ¸ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤."""
+        self.ws_client = WebSocketClient(WS_URL)
+        self.ws_client.message_received.connect(self._distribute_message)
+        self.ws_client.start()
+    
+    def _init_timers(self):
+        """íƒ€ì´ë¨¸ ì´ˆê¸°í™”"""
+        # ë¶„ì„ íƒ€ì´ë¨¸
+        self.analysis_timer = QTimer(self)
+        self.analysis_timer.setInterval(2000)
+        self.analysis_timer.timeout.connect(self._on_analyze_timing)
+        
+        # ì‹œê°„ ê³ ì • ê²½ê³¼ ì‹œê°„ í‘œì‹œ íƒ€ì´ë¨¸ (ìƒì„±ì€ í•˜ì§€ë§Œ ì‹œì‘í•˜ì§€ ì•ŠìŒ)
+        self.fixed_time_timer = QTimer(self)
+        self.fixed_time_timer.timeout.connect(self._update_fixed_time_display)
+    
+    @Slot(dict)
+    def _distribute_message(self, message: dict):
+        """ìˆ˜ì‹ ëœ ë©”ì‹œì§€ë¥¼ ì ì ˆí•œ í•˜ìœ„ ìœ„ì ¯ìœ¼ë¡œ ë¶„ë°°í•©ë‹ˆë‹¤."""
+        msg_type = message.get("type")
+        self.logger.debug(f"WebSocket ë©”ì‹œì§€ ìˆ˜ì‹ : {msg_type}")
+
+        # í—¤ë” ìœ„ì ¯ ë©”ì‹œì§€ ì²˜ë¦¬
+        if hasattr(self.header_widget, 'handle_message'):
+            self.header_widget.handle_message(message)
+        
+        # START ì´ì „ì—ëŠ” í—¤ë”/ê¸´ê¸‰/ì—ëŸ¬ë§Œ ì²˜ë¦¬í•˜ê³  ë‚˜ë¨¸ì§€ëŠ” ë¬´ì‹œ
+        if not self._app_started:
+            if msg_type == "EMERGENCY_LIQUIDATION":
+                self._handle_emergency_liquidation(message.get("data", {}))
+            elif msg_type == "CRITICAL_ERROR":
+                self.handle_critical_error(message.get("title", "ì˜¤ë¥˜"), message.get("message", "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜"))
+            # í—¤ë” ì—…ë°ì´íŠ¸ì—ì„œ Account total balanceë§Œ í‘¸í„° ìœ„ì ¯ì— ë°˜ì˜í•˜ëŠ” ê²ƒì€ í—ˆìš©
+            if msg_type == "HEADER_UPDATE":
+                header_data = message.get("data", {})
+                available_funds = header_data.get("available_funds", 0.0)
+                self.middle_session_widget.alpha_engine.set_account_total_balance(available_funds)
+                self.middle_session_widget.beta_engine.set_account_total_balance(available_funds)
+                self.middle_session_widget.gamma_engine.set_account_total_balance(available_funds)
+            return
+
+        # HEADER_UPDATE ë©”ì‹œì§€ ì²˜ë¦¬ - Account total balanceë¥¼ ì—”ì§„ ìœ„ì ¯ì— ì „ë‹¬ (START ì´í›„ì—ë„ ìœ ì§€)
+        if msg_type == "HEADER_UPDATE":
+            header_data = message.get("data", {})
+            available_funds = header_data.get("available_funds", 0.0)
+            # ê° ì—”ì§„ ìœ„ì ¯ì— Account total balance ì „ë‹¬
+            self.middle_session_widget.alpha_engine.set_account_total_balance(available_funds)
+            self.middle_session_widget.beta_engine.set_account_total_balance(available_funds)
+            self.middle_session_widget.gamma_engine.set_account_total_balance(available_funds)
+
+        # ì¤‘ë‹¨ ì„¸ì…˜/í‘¸í„° ë©”ì‹œì§€ ì²˜ë¦¬ (START ì´í›„ì—ë§Œ)
+        if hasattr(self.middle_session_widget, 'handle_message'):
+            self.middle_session_widget.handle_message(message)
+        # ë©”ì‹œì§€ íƒ€ì…ë³„ ì²˜ë¦¬ (START ì´í›„)
+        if msg_type == "BINANCE_LIVE_RANKING" or msg_type == "RANKING_UPDATE":
+            items = message.get("data", [])
+            self.ranking_table.populate(items)
+        elif msg_type == "SETTLING_UPDATE":
+            settling_data = message.get("data", [])
+            self.settling_table.populate(settling_data)
+        elif msg_type == "TIMING_ANALYSIS_UPDATE":
+            analysis_data = message.get("data", {})
+            self._apply_analysis_data(analysis_data)
+        elif msg_type == "EMERGENCY_LIQUIDATION":
+            self._handle_emergency_liquidation(message.get("data", {}))
+        elif msg_type == "CRITICAL_ERROR":
+            self.handle_critical_error(message.get("title", "ì˜¤ë¥˜"), message.get("message", "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜"))
+    
+    def _handle_emergency_liquidation(self, data: dict):
+        """ê¸´ê¸‰ í¬ì§€ì…˜ ì²­ì‚° ê²°ê³¼ ì²˜ë¦¬ ë° ì‚¬ìš©ì í”¼ë“œë°±"""
+        status = data.get("status")
+        msg = data.get("message", "")
+        
+        if status == "success":
+            closed_count = data.get("closed_count", 0)
+            closed_positions = data.get("closed_positions", [])
+            
+            # ì²­ì‚°ëœ í¬ì§€ì…˜ ëª©ë¡ ìƒì„±
+            position_details = "\n".join([
+                f"  â€¢ {p['symbol']}: {p['amount']:.4f} ({p['side']})"
+                for p in closed_positions
+            ]) if closed_positions else "  ì—†ìŒ"
+            
+            QMessageBox.information(
+                self,
+                "âœ… ê¸´ê¸‰ í¬ì§€ì…˜ ì²­ì‚° ì™„ë£Œ",
+                f"{msg}\n\nì²­ì‚°ëœ í¬ì§€ì…˜ ({closed_count}ê°œ):\n{position_details}"
+            )
+            self.logger.info(f"ê¸´ê¸‰ ì²­ì‚° ì„±ê³µ: {closed_count}ê°œ í¬ì§€ì…˜")
+            
+        elif status == "partial_failure":
+            errors = data.get("errors", [])
+            
+            # ì‹¤íŒ¨í•œ í¬ì§€ì…˜ ëª©ë¡ ìƒì„±
+            error_details = "\n".join([
+                f"  â€¢ {e['symbol']}: {e['error']}"
+                for e in errors
+            ]) if errors else "  ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜"
+            
+            QMessageBox.warning(
+                self,
+                "âš ï¸ ê¸´ê¸‰ í¬ì§€ì…˜ ì²­ì‚° ë¶€ë¶„ ì‹¤íŒ¨",
+                f"{msg}\n\nì‹¤íŒ¨í•œ í¬ì§€ì…˜ ({len(errors)}ê°œ):\n{error_details}\n\n"
+                "ì„±ê³µí•œ í¬ì§€ì…˜ì€ ì •ìƒì ìœ¼ë¡œ ì²­ì‚°ë˜ì—ˆìŠµë‹ˆë‹¤."
+            )
+            self.logger.warning(f"ê¸´ê¸‰ ì²­ì‚° ë¶€ë¶„ ì‹¤íŒ¨: {len(errors)}ê°œ í¬ì§€ì…˜ ì‹¤íŒ¨")
+            
+        else:  # error
+            QMessageBox.critical(
+                self,
+                "âŒ ê¸´ê¸‰ í¬ì§€ì…˜ ì²­ì‚° ì˜¤ë¥˜",
+                f"{msg}\n\ní¬ì§€ì…˜ ì²­ì‚° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.\n"
+                "ë°”ì´ë‚¸ìŠ¤ ê³„ì •ì„ ì§ì ‘ í™•ì¸í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤."
+            )
+            self.logger.error(f"ê¸´ê¸‰ ì²­ì‚° ì˜¤ë¥˜: {msg}")
+    
+    @Slot(object)
+    def _apply_analysis_data(self, data: dict):
+        """ë¶„ì„ ë°ì´í„°ë¥¼ ìœ„ì ¯ì— ì ìš© (UI ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰ë¨)"""
+        try:
+            print(f"[MAIN] ğŸ“Š ë¶„ì„ ë°ì´í„° ì ìš© ì‹œì‘ (UI ìŠ¤ë ˆë“œ)")
+            
+            # ì¶”ì„¸ ë¶„ì„
+            trend = data.get("trend_analysis", {})
+            if trend:
+                print(f"[MAIN] ğŸ¯ ì¶”ì„¸ ë¶„ì„ ì—…ë°ì´íŠ¸: {trend.get('overall', 'N/A')}")
+                self.trend_analysis.update_trend(trend)
+            
+            # ì°¨íŠ¸
+            print(f"[MAIN] ğŸ“ˆ ì°¨íŠ¸ ë°ì´í„° ì—…ë°ì´íŠ¸")
+            self.analysis_view.set_data(data)
+            print(f"[MAIN] âœ… ë¶„ì„ ë°ì´í„° ì ìš© ì™„ë£Œ")
+            
+        except Exception as e:
+            print(f"[MAIN] âŒë¶„ì„ ë°ì´í„° ì ìš© ì˜¤ë¥˜: {e}")
+            self.logger.error(f"ë¶„ì„ ë°ì´í„° ì ìš© ì˜¤ë¥˜: {e}")
+
+    @Slot()
+    def on_start_clicked(self):
+        """START ë²„íŠ¼ í´ë¦­ ì‹œ ë°±ì—”ë“œì— API ìš”ì²­"""
+        try:
+            response = requests.post(f"{BASE_URL}/api/v1/start", timeout=5)
+            response.raise_for_status()
+            self.logger.info("ë°±ì—”ë“œì— START ëª…ë ¹ ì „ì†¡ ì™„ë£Œ.")
+            self._app_started = True
+        except requests.exceptions.RequestException as e:
+            self.logger.error(f"START ëª…ë ¹ ì „ì†¡ ì‹¤íŒ¨: {e}")
+            self.handle_critical_error("ì—°ê²° ì˜¤ë¥˜", "ë°±ì—”ë“œì— START ëª…ë ¹ì„ ë³´ë‚¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
+
+    @Slot()
+    def on_stop_clicked(self):
+        """STOP ë²„íŠ¼ í´ë¦­ ì‹œ ë¶„ì„ ì¤‘ì§€ (ê¸´ê¸‰ ì²­ì‚° ì—†ì´)"""
+        try:
+            response = requests.post(f"{BASE_URL}/api/v1/stop", timeout=5)
+            response.raise_for_status()
+            self.logger.info("ë°±ì—”ë“œì— STOP ëª…ë ¹ ì „ì†¡ ì™„ë£Œ.")
+            # ì „ì²´ ì•± ë¹„í™œì„± ì²˜ë¦¬: ì¤‘ë‹¨ ì„¸ì…˜/í‘¸í„° ë©”ì‹œì§€ ë¬´ì‹œ, íƒ€ì´ë¨¸ ì •ì§€
+            self._app_started = False
+            if hasattr(self, 'analysis_timer') and self.analysis_timer.isActive():
+                self.analysis_timer.stop()
+            self.selected_symbol = ""
+        except requests.exceptions.RequestException as e:
+            self.logger.error(f"STOP ëª…ë ¹ ì „ì†¡ ì‹¤íŒ¨: {e}")
+            QMessageBox.critical(
+                self,
+                "ì—°ê²° ì˜¤ë¥˜",
+                f"ë°±ì—”ë“œ ì„œë²„ì™€ í†µì‹ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n\nì˜¤ë¥˜: {str(e)}"
+            )
+    
+    @Slot()
+    def on_emergency_liquidation_clicked(self):
+        """ê¸´ê¸‰ ì²­ì‚° ë²„íŠ¼ í´ë¦­ ì‹œ ëª¨ë“  í¬ì§€ì…˜ ì‹œì¥ê°€ ì²­ì‚°"""
+        # ê¸´ê¸‰ ì²­ì‚° í™•ì¸ ë‹¤ì´ì–¼ë¡œê·¸
+        reply = QMessageBox.warning(
+            self,
+            "âš ï¸ ê¸´ê¸‰ í¬ì§€ì…˜ ì²­ì‚°",
+            "ëª¨ë“  í™œì„± í¬ì§€ì…˜ì„ ì‹œì¥ê°€ë¡œ ì¦‰ì‹œ ì²­ì‚°í•©ë‹ˆë‹¤.\n"
+            "ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n\n"
+            "ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
+            QMessageBox.Yes | QMessageBox.No,
+            QMessageBox.No
+        )
+        
+        if reply == QMessageBox.No:
+            self.logger.info("ì‚¬ìš©ìê°€ ê¸´ê¸‰ ì²­ì‚°ì„ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.")
+            return
+        
+        try:
+            # ê¸´ê¸‰ ì²­ì‚° API í˜¸ì¶œ
+            response = requests.post(f"{BASE_URL}/api/v1/emergency/liquidate", timeout=10)
+            response.raise_for_status()
+            self.logger.info("ê¸´ê¸‰ ì²­ì‚° ëª…ë ¹ ì „ì†¡ ì™„ë£Œ.")
+        except requests.exceptions.RequestException as e:
+            self.logger.error(f"ê¸´ê¸‰ ì²­ì‚° ëª…ë ¹ ì „ì†¡ ì‹¤íŒ¨: {e}")
+            QMessageBox.critical(
+                self,
+                "ì—°ê²° ì˜¤ë¥˜",
+                f"ë°±ì—”ë“œ ì„œë²„ì™€ í†µì‹ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n\nì˜¤ë¥˜: {str(e)}"
+            )
+    
+    @Slot(str)
+    def _on_engine_start(self, engine_name: str):
+        """íŠ¹ì • ì—”ì§„ ì‹œì‘ ìš”ì²­"""
+        if not self._app_started:
+            QMessageBox.information(self, "ì•± ëŒ€ê¸° ìƒíƒœ", "ë¨¼ì € ìƒë‹¨ì˜ START ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.")
+            return
+        try:
+            # NewModular ì—”ì§„ì€ ë³„ë„ API ì‚¬ìš©
+            if engine_name == "NewModular":
+                response = requests.post(
+                    f"{BASE_URL}/api/v1/strategy/new/start",
+                    json={
+                        "symbol": "BTCUSDT",  # ê¸°ë³¸ê°’, ì¶”í›„ ì„¤ì •ì—ì„œ ê°€ì ¸ì˜¤ê¸°
+                        "leverage": 10,
+                        "quantity": None
+                    },
+                    timeout=5
+                )
+            else:
+                # Alpha/Beta/Gamma ì—”ì§„: GUIì—ì„œ ì„ íƒëœ ì‹¬ë³¼ ê°€ì ¸ì˜¤ê¸°
+                selected_symbol = None
+                if engine_name == "Alpha":
+                    selected_symbol = self.middle_session_widget.alpha_engine.selected_symbol
+                elif engine_name == "Beta":
+                    selected_symbol = self.middle_session_widget.beta_engine.selected_symbol
+                elif engine_name == "Gamma":
+                    selected_symbol = self.middle_session_widget.gamma_engine.selected_symbol
+                
+                # ì‹¬ë³¼ì´ ì§€ì •ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©
+                if not selected_symbol:
+                    selected_symbol = "BTCUSDT"
+                    self.logger.warning(f"{engine_name} ì—”ì§„ ì‹¬ë³¼ ë¯¸ì§€ì •, ê¸°ë³¸ê°’ ì‚¬ìš©: {selected_symbol}")
+                
+                response = requests.post(
+                    f"{BASE_URL}/api/v1/engine/start",
+                    json={"engine": engine_name, "symbol": selected_symbol},
+                    timeout=5
+                )
+            response.raise_for_status()
+            self.logger.info(f"{engine_name} ì—”ì§„ ì‹œì‘ ìš”ì²­ ì™„ë£Œ.")
+        except requests.exceptions.RequestException as e:
+            self.logger.error(f"{engine_name} ì—”ì§„ ì‹œì‘ ì‹¤íŒ¨: {e}")
+            QMessageBox.warning(self, "ì—”ì§„ ì‹œì‘ ì‹¤íŒ¨", f"{engine_name} ì—”ì§„ì„ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
+    
+    @Slot(str)
+    def _on_engine_stop(self, engine_name: str):
+        """íŠ¹ì • ì—”ì§„ ì •ì§€ ìš”ì²­"""
+        if not self._app_started:
+            # ëŒ€ê¸° ìƒíƒœì—ì„œë„ ê°œë³„ ì—”ì§„ ì •ì§€ëŠ” ë³´ë‚¼ í•„ìš” ì—†ìŒ
+            return
+        try:
+            # NewModular ì—”ì§„ì€ ë³„ë„ API ì‚¬ìš©
+            if engine_name == "NewModular":
+                response = requests.post(
+                    f"{BASE_URL}/api/v1/strategy/new/stop",
+                    json={"force": False},  # í¬ì§€ì…˜ ë³´ìœ  ì‹œ ê²½ê³ 
+                    timeout=5
+                )
+            else:
+                response = requests.post(
+                    f"{BASE_URL}/api/v1/engine/stop",
+                    json={"engine": engine_name},
+                    timeout=5
+                )
+            response.raise_for_status()
+            self.logger.info(f"{engine_name} ì—”ì§„ ì •ì§€ ìš”ì²­ ì™„ë£Œ.")
+        except requests.exceptions.RequestException as e:
+            self.logger.error(f"{engine_name} ì—”ì§„ ì •ì§€ ì‹¤íŒ¨: {e}")
+            QMessageBox.warning(self, "ì—”ì§„ ì •ì§€ ì‹¤íŒ¨", f"{engine_name} ì—”ì§„ì„ ì •ì§€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
+            self.handle_critical_error("ì—°ê²° ì˜¤ë¥˜", "ë°±ì—”ë“œì— STOP ëª…ë ¹ì„ ë³´ë‚¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
+    
+    # ê¸‰ë“± ì˜ˆìƒ ì½”ì¸ ê¸°ëŠ¥ ì™„ì „ ì‚­ì œ
+    
+    def _on_analyze_symbol(self, symbol: str):
+        """ë­í‚¹ í…Œì´ë¸”ì—ì„œ ë¶„ì„ ìš”ì²­"""
+        if not self._app_started:
+            from PySide6.QtWidgets import QMessageBox
+            QMessageBox.information(self, "ì•± ëŒ€ê¸° ìƒíƒœ", "ë¨¼ì € START ë²„íŠ¼ì„ ëˆŒëŸ¬ ë¶„ì„ì„ ì‹œì‘í•˜ì„¸ìš”.")
+            return
+        print(f"[MAIN] _on_analyze_symbol í˜¸ì¶œë¨: symbol={symbol}")
+        self.selected_symbol = symbol
+        
+        # í—¤ë” ì‹¬ë³¼ ë¼ë²¨ ì—…ë°ì´íŠ¸
+        self.entry_symbol_label.setText(symbol)
+        
+        print(f"[MAIN] selected_symbol ì„¤ì •: {self.selected_symbol}")
+        self._start_analysis()
+    
+    def _start_analysis(self):
+        """ë¶„ì„ ì‹œì‘"""
+        print(f"[MAIN] _start_analysis í˜¸ì¶œë¨")
+        self._analysis_inflight = False
+        if not self.analysis_timer.isActive():
+            print(f"[MAIN] â° analysis_timer ì‹œì‘")
+            self.analysis_timer.start()
+        else:
+            print(f"[MAIN] â° analysis_timer ì´ë¯¸ ì‹¤í–‰ ì¤‘")
+        self._on_analyze_timing()
+    
+    def _on_analyze_timing(self):
+        """íƒ€ì´ë° ë¶„ì„ ì‹¤í–‰"""
+        if not self.selected_symbol:
+            print(f"[MAIN] âŒ selected_symbolì´ ì—†ì–´ì„œ ë¶„ì„ì„ ê±´ë„ˆëœë‹ˆë‹¤.")
+            return
+        
+        symbol = self.selected_symbol
+        print(f"[MAIN] ğŸ“Š íƒ€ì´ë° ë¶„ì„ ì‹œì‘: {symbol}")
+        
+        def worker():
+            try:
+                self._analysis_inflight = True
+                print(f"[MAIN] ğŸŒ API í˜¸ì¶œ: /api/v1/live/analysis/entry?symbol={symbol}")
+                response = requests.get(
+                    f"{BASE_URL}/api/v1/live/analysis/entry",
+                    params={"symbol": symbol},
+                    timeout=5
+                )
+                if response.ok:
+                    data = response.json().get("data", {})
+                    print(f"[MAIN] âœ… API ì‘ë‹µ ìˆ˜ì‹ : {len(data)} keys")
+                else:
+                    print(f"[MAIN] âš ï¸ API ì‹¤íŒ¨ (status={response.status_code}), ê¸°ë³¸ ë°ì´í„° ì‚¬ìš©")
+                    data = self._get_default_analysis_data(symbol)
+            except Exception as e:
+                print(f"[MAIN] âŒ API ì˜¤ë¥˜: {e}, ê¸°ë³¸ ë°ì´í„° ì‚¬ìš©")
+                data = self._get_default_analysis_data(symbol)
+            finally:
+                # Signalì„ í†µí•´ UI ìŠ¤ë ˆë“œì—ì„œ ì—…ë°ì´íŠ¸ (Qt ê·œì¹™ ì¤€ìˆ˜!)
+                try:
+                    print(f"[MAIN] ğŸ“¡ analysis_ready Signal ë°œìƒ")
+                    self.analysis_ready.emit(data)
+                except Exception as e:
+                    print(f"[MAIN] âŒ Signal ë°œìƒ ì˜¤ë¥˜: {e}")
+                self._analysis_inflight = False
+        
+        threading.Thread(target=worker, daemon=True).start()
+    
+    def _get_default_analysis_data(self, symbol: str) -> dict:
+        """ê¸°ë³¸ ë¶„ì„ ë°ì´í„° (API ì‹¤íŒ¨ ì‹œ)"""
+        return {
+            "symbol": symbol,
+            "score": 0,
+            "series": {
+                "close": [], "ema20": [], "ema50": [], 
+                "vwap": [], "bpr": [], "vss": []
+            },
+            "trend_analysis": {
+                "5m": {
+                    "direction": "ì—°ê²°ì¤‘", "strength": 0, 
+                    "predicted_upside": 0.0, 
+                    "price_status": {"status": "ëŒ€ê¸°"}
+                },
+                "15m": {
+                    "direction": "ì—°ê²°ì¤‘", "strength": 0, 
+                    "predicted_upside": 0.0, 
+                    "price_status": {"status": "ëŒ€ê¸°"}
+                },
+                "overall": "ë°”ì´ë‚¸ìŠ¤ API ì—°ê²° ì¤‘"
+            },
+            "levels": {"entry_zone": {}, "stop": None, "tp1": None, "tp2": None}
+        }
+    
+    def _on_add_blacklist(self):
+        """ë­í‚¹ í…Œì´ë¸”ì—ì„œ ì„ íƒëœ ì‹¬ë³¼ì„ ë¸”ë™ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€ (Binance Live vs1 íŒ¨í„´)"""
+        try:
+            symbols = self.ranking_table.get_checked_symbols()
+            if not symbols:
+                return
+            
+            response = requests.post(
+                f"{BASE_URL}/api/v1/live/blacklist/add",
+                json={"symbols": symbols},
+                timeout=5
+            )
+            
+            if response.status_code == 200:
+                self.ranking_table.clear_all_checks()
+                self._refresh_blacklist_tab()  # í—¬í¼ ë©”ì„œë“œ ì‚¬ìš©
+        except Exception as e:
+            self.logger.error(f"ë¸”ë™ë¦¬ìŠ¤íŠ¸ ì¶”ê°€ ì‹¤íŒ¨: {e}")
+    
+    def _on_add_settling_blacklist(self):
+        """SETTLING í…Œì´ë¸”ì—ì„œ ì„ íƒëœ ì‹¬ë³¼ì„ ë¸”ë™ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€ (Binance Live vs1 íŒ¨í„´)"""
+        try:
+            symbols = self.settling_table.get_checked_symbols()
+            if not symbols:
+                return
+            
+            response = requests.post(
+                f"{BASE_URL}/api/v1/live/blacklist/add",
+                json={"symbols": symbols, "status": "SETTLING"},
+                timeout=5
+            )
+            
+            if response.status_code == 200:
+                self.settling_table.clear_all_checks()
+                self._refresh_blacklist_tab()  # í—¬í¼ ë©”ì„œë“œ ì‚¬ìš©
+        except Exception as e:
+            self.logger.error(f"SETTLING ë¸”ë™ë¦¬ìŠ¤íŠ¸ ì¶”ê°€ ì‹¤íŒ¨: {e}")
+    
+    def _on_remove_blacklist(self):
+        """ë¸”ë™ë¦¬ìŠ¤íŠ¸ì—ì„œ ì„ íƒëœ ì‹¬ë³¼ ì œê±° (Binance Live vs1 íŒ¨í„´)"""
+        try:
+            symbols = self.blacklist_table.get_checked_symbols()
+            if not symbols:
+                return
+            
+            response = requests.post(
+                f"{BASE_URL}/api/v1/live/blacklist/remove",
+                json={"symbols": symbols},
+                timeout=5
+            )
+            
+            if response.status_code == 200:
+                self.blacklist_table.clear_all_checks()
+                self._refresh_blacklist_tab()  # í—¬í¼ ë©”ì„œë“œ ì‚¬ìš©
+        except Exception as e:
+            self.logger.error(f"ë¸”ë™ë¦¬ìŠ¤íŠ¸ ì œê±° ì‹¤íŒ¨: {e}")
+    
+    def _on_tab_changed(self, index: int):
+        """íƒ­ ë³€ê²½ ì‹œ í˜¸ì¶œ"""
+        if not self._app_started:
+            return
+        if index == 1:  # ë¸”ë™ë¦¬ìŠ¤íŠ¸ íƒ­
+            self._load_blacklist_data()
+    
+    def _load_blacklist_data(self):
+        """ë¸”ë™ë¦¬ìŠ¤íŠ¸ ë°ì´í„° ë¡œë”© (Binance Live vs1 íŒ¨í„´)"""
+        if self._blacklist_loading:
+            return
+        
+        def worker():
+            try:
+                self._blacklist_loading = True
+                response = requests.get(f"{BASE_URL}/api/v1/live/blacklist", timeout=5)
+                
+                if response.status_code == 200:
+                    data = response.json().get("data", [])
+                    # UI ìŠ¤ë ˆë“œì—ì„œ ì—…ë°ì´íŠ¸ - Signal ë°©ì‹ìœ¼ë¡œ ë³€ê²½ (ìŠ¤ë ˆë“œ ì•ˆì „)
+                    self.blacklist_data_received.emit(data)
+            except Exception as e:
+                self.logger.error(f"ë¸”ë™ë¦¬ìŠ¤íŠ¸ ë¡œë”© ì‹¤íŒ¨: {e}")
+            finally:
+                self._blacklist_loading = False
+        
+        threading.Thread(target=worker, daemon=True).start()
+    
+    def _update_blacklist_table(self, data):
+        """ë¸”ë™ë¦¬ìŠ¤íŠ¸ í…Œì´ë¸” ì—…ë°ì´íŠ¸ (Signal ìˆ˜ì‹  í•¸ë“¤ëŸ¬)"""
+        try:
+            self.blacklist_table.populate(data)
+            self.logger.info(f"ë¸”ë™ë¦¬ìŠ¤íŠ¸ í…Œì´ë¸” ì—…ë°ì´íŠ¸ ì™„ë£Œ: {len(data)}ê°œ í•­ëª©")
+        except Exception as e:
+            self.logger.error(f"ë¸”ë™ë¦¬ìŠ¤íŠ¸ í…Œì´ë¸” ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
+    
+    def _refresh_blacklist_tab(self):
+        """ë¸”ë™ë¦¬ìŠ¤íŠ¸ íƒ­ ìƒˆë¡œê³ ì¹¨ (Binance Live vs1 íŒ¨í„´)"""
+        QTimer.singleShot(500, self._load_blacklist_data)
+
+    def _on_time_fix_clicked(self) -> None:
+        """ì‹œê°„ ê³ ì • ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸ ì²˜ë¦¬"""
+        if self.fixed_time is None:
+            # ì‹œê°„ ê³ ì • ì‹œì‘
+            self.fixed_time = datetime.utcnow()
+            self.time_fix_button.setText("[ê³ ì •í•´ì œ]")
+            threading.Thread(target=self._send_fixed_time, args=(self.fixed_time,), daemon=True).start()
+            self.fixed_time_timer.start(1000)  # 1ì´ˆë§ˆë‹¤ ê²½ê³¼ ì‹œê°„ ì—…ë°ì´íŠ¸
+            self.logger.info(f"ì‹œê°„ ê³ ì • ì‹œì‘: {self.fixed_time}")
+        else:
+            # ì‹œê°„ ê³ ì • í•´ì œ
+            self.fixed_time = None
+            self.time_fix_button.setText("[ì‹œê°„ê³ ì •]")
+            threading.Thread(target=self._send_fixed_time, args=(None,), daemon=True).start()
+            self.fixed_time_timer.stop()
+            self.fixed_time_label.setText("[--:--:--]")
+            self.logger.info("ì‹œê°„ ê³ ì • í•´ì œ")
+
+    def _update_fixed_time_display(self) -> None:
+        """ì‹œê°„ ê³ ì • í›„ ê²½ê³¼ ì‹œê°„ì„ í‘œì‹œ"""
+        if self.fixed_time:
+            elapsed = datetime.utcnow() - self.fixed_time
+            hours, remainder = divmod(elapsed.total_seconds(), 3600)
+            minutes, seconds = divmod(remainder, 60)
+            self.fixed_time_label.setText(f"[{int(hours):02d}:{int(minutes):02d}:{int(seconds):02d}]")
+
+    def _send_fixed_time(self, fixed_time: Optional[datetime] = None) -> None:
+        """ë°±ì—”ë“œì— ì‹œê°„ ê³ ì • ì„¤ì • ì „ì†¡"""
+        try:
+            data = {"fixed_time": fixed_time.isoformat() if fixed_time else None}
+            response = requests.post(f"{BASE_URL}/api/v1/set-fixed-time", json=data, timeout=5)
+            if response.status_code == 200:
+                self.logger.info(f"ì‹œê°„ ê³ ì • ì„¤ì • ì „ì†¡ ì™„ë£Œ: {data}")
+            else:
+                self.logger.warning(f"ì‹œê°„ ê³ ì • ì„¤ì • ì‹¤íŒ¨: {response.status_code}")
+        except Exception as e:
+            self.logger.error(f"ì‹œê°„ ê³ ì • ì„¤ì • ì „ì†¡ ì˜¤ë¥˜: {e}")
+    
+    def _on_reset_initial_investment(self):
+        """Initial Investment ë²„íŠ¼ í´ë¦­ ì²˜ë¦¬"""
+        try:
+            response = requests.post(f"{BASE_URL}/api/v1/account/initial/reset", timeout=8)
+            response.raise_for_status()
+            data = response.json().get("data", {})
+            amount = data.get("initial_investment", 0.0)
+            QMessageBox.information(
+                self,
+                "Initial Investment",
+                f"ì´ˆê¸° íˆ¬ìê¸ˆì´ {amount:,.2f} USDTë¡œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤."
+            )
+            self.logger.info(f"Initial Investment ì¬ì„¤ì • ì™„ë£Œ: {amount:.2f} USDT")
+        except requests.exceptions.RequestException as e:
+            self.logger.error(f"Initial Investment ì¬ì„¤ì • ì‹¤íŒ¨: {e}")
+            QMessageBox.warning(
+                self,
+                "ì„¤ì • ì‹¤íŒ¨",
+                "Binance ê³„ì¢Œ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\në„¤íŠ¸ì›Œí¬ ìƒíƒœë¥¼ í™•ì¸í•´ ì£¼ì„¸ìš”."
+            )
+
+    def handle_critical_error(self, title: str, message: str):
+        self.logger.critical(f"GUI - ì¹˜ëª…ì ì¸ ì˜¤ë¥˜: [{title}] {message}")
+        QMessageBox.critical(self, title, message)
+
+    def closeEvent(self, event):
+        """ë©”ì¸ ìœˆë„ìš° ì¢…ë£Œ ì´ë²¤íŠ¸ ì²˜ë¦¬"""
+        self.logger.info("GUI ìœˆë„ìš° ì¢…ë£Œ ì¤‘...")
+        
+        # íƒ€ì´ë¨¸ ì •ì§€
+        if hasattr(self, 'analysis_timer'):
+            self.analysis_timer.stop()
+        if hasattr(self, 'fixed_time_timer'):
+            self.fixed_time_timer.stop()
+        
+        # WebSocket ì—°ê²° ì¢…ë£Œ
+        if hasattr(self, 'ws_client'):
+            self.ws_client.stop()
+        
+        event.accept()
+    
+    
+    # ========================================
+    # ë°±í…ŒìŠ¤íŠ¸ ê´€ë ¨ í•¸ë“¤ëŸ¬
+    # ========================================
+    
+    def _on_backtest_requested(self, symbol: str):
+        """
+        ë°±í…ŒìŠ¤íŠ¸ ì‹œì‘ ìš”ì²­
+        
+        í”Œë¡œìš°:
+        1. UI ìƒíƒœ ë³€ê²½ (ì»¬ëŸ¼ 1ì„ "ë¶„ì„ì¤‘"ìœ¼ë¡œ)
+        2. ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œì—ì„œ API í˜¸ì¶œ
+        3. ê²°ê³¼ ìˆ˜ì‹  ì‹œ Signalë¡œ UI ì—…ë°ì´íŠ¸
+        
+        Args:
+            symbol: ì½”ì¸ ì‹¬ë³¼
+        """
+        print(f"[MAIN] ğŸ”¬ ë°±í…ŒìŠ¤íŠ¸ ì‹œì‘: {symbol}")
+        
+        # 1. UI ìƒíƒœ ë³€ê²½ (ì»¬ëŸ¼ 1ì„ "ë¶„ì„ì¤‘"ìœ¼ë¡œ)
+        self._update_backtest_status(symbol, "ë¶„ì„ì¤‘", 0)
+        
+        # 2. ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë°±í…ŒìŠ¤íŠ¸ ì‹¤í–‰ (UI ë¸”ë¡œí‚¹ ë°©ì§€)
+        def worker():
+            try:
+                print(f"[MAIN] ğŸŒ ë°±í…ŒìŠ¤íŠ¸ API í˜¸ì¶œ: {symbol}")
+                
+                # API í˜¸ì¶œ (íƒ€ì„ì•„ì›ƒ 30ì´ˆ - ë°±í…ŒìŠ¤íŠ¸ëŠ” ì‹œê°„ ì†Œìš”)
+                response = requests.get(
+                    f"{BACKTEST_BASE_URL}/api/v1/backtest/suitability",
+                    params={"symbol": symbol, "period": "1w"},
+                    timeout=30
+                )
+                
+                if response.ok:
+                    data = response.json().get("data", {})
+                    suitability = data.get("suitability", "ë¶€ì í•©")
+                    score = data.get("score", 0)
+                    metrics = data.get("metrics", {})
+                    cached = response.json().get("cached", False)
+                    
+                    cache_msg = "ìºì‹œ" if cached else "ì‹ ê·œ"
+                    print(f"[MAIN] âœ… ë°±í…ŒìŠ¤íŠ¸ ì™„ë£Œ ({cache_msg}): {symbol} -> {suitability} ({score}ì )")
+                    
+                    # UI ì—…ë°ì´íŠ¸ (Signal ì‚¬ìš©)
+                    self.backtest_completed.emit(symbol, suitability, score, metrics)
+                else:
+                    error = f"API ì˜¤ë¥˜ (status={response.status_code})"
+                    print(f"[MAIN] âŒ ë°±í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: {symbol} -> {error}")
+                    self.backtest_failed.emit(symbol, error)
+            
+            except requests.Timeout:
+                error = "íƒ€ì„ì•„ì›ƒ (30ì´ˆ ì´ˆê³¼)"
+                print(f"[MAIN] â±ï¸ ë°±í…ŒìŠ¤íŠ¸ íƒ€ì„ì•„ì›ƒ: {symbol}")
+                self.backtest_failed.emit(symbol, error)
+            
+            except Exception as e:
+                error = str(e)
+                print(f"[MAIN] âŒ ë°±í…ŒìŠ¤íŠ¸ ì˜ˆì™¸: {symbol} -> {error}")
+                self.backtest_failed.emit(symbol, error)
+        
+        # ë°ëª¬ ìŠ¤ë ˆë“œë¡œ ì‹¤í–‰ (GUI ë©”ì¸ ìŠ¤ë ˆë“œ ë¸”ë¡œí‚¹ ë°©ì§€)
+        threading.Thread(target=worker, daemon=True).start()
+    
+    def _update_backtest_status(self, symbol: str, status: str, score: float):
+        """
+        ë°±í…ŒìŠ¤íŠ¸ ìƒíƒœ ì—…ë°ì´íŠ¸ (ë­í‚¹ í…Œì´ë¸” ì»¬ëŸ¼ 1)
+        
+        Args:
+            symbol: ì½”ì¸ ì‹¬ë³¼
+            status: "ëŒ€ê¸°" | "ë¶„ì„ì¤‘" | "ì í•©" | "ë¶€ì í•©" | "ì£¼ì˜ í•„ìš”"
+            score: 0~100 ì ìˆ˜
+        """
+        # í…Œì´ë¸”ì—ì„œ í•´ë‹¹ ì‹¬ë³¼ í–‰ ì°¾ê¸°
+        for row in range(self.ranking_table.rowCount()):
+            symbol_widget = self.ranking_table.cellWidget(row, 2)
+            if symbol_widget and symbol_widget.property("symbol") == symbol:
+                # ì»¬ëŸ¼ 1 (ê±°ë˜ ì í•©ì„±) ì—…ë°ì´íŠ¸
+                if status == "ì í•©":
+                    text = f"âœ… ì í•© ({score:.0f})"
+                    color = "#03b662"
+                elif status == "ë¶€ì í•©":
+                    text = f"âŒ ë¶€ì í•© ({score:.0f})"
+                    color = "#e16476"
+                elif status == "ì£¼ì˜ í•„ìš”":
+                    text = f"âš ï¸ ì£¼ì˜ ({score:.0f})"
+                    color = "#ff8c25"
+                elif status == "ë¶„ì„ì¤‘":
+                    text = "â³ ë¶„ì„ì¤‘..."
+                    color = "#1e88e5"
+                else:  # "ëŒ€ê¸°"
+                    text = "-"
+                    color = "#3c3c3c"
+                
+                from PySide6.QtWidgets import QTableWidgetItem
+                from PySide6.QtGui import QColor, QFont
+                item = QTableWidgetItem(text)
+                item.setTextAlignment(Qt.AlignCenter)
+                item.setForeground(QColor(color))
+                font = QFont()
+                font.setBold(True)
+                item.setFont(font)
+                self.ranking_table.setItem(row, 1, item)
+                break
+    
+    def _on_backtest_completed(self, symbol: str, suitability: str, score: float, metrics: dict):
+        """
+        ë°±í…ŒìŠ¤íŠ¸ ì™„ë£Œ ì²˜ë¦¬ (UI ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰)
+        
+        Args:
+            symbol: ì½”ì¸ ì‹¬ë³¼
+            suitability: ì í•©ì„± ("ì í•©" | "ë¶€ì í•©" | "ì£¼ì˜ í•„ìš”")
+            score: ì ìˆ˜ (0~100)
+            metrics: ë°±í…ŒìŠ¤íŠ¸ ë©”íŠ¸ë¦­ ë”•ì…”ë„ˆë¦¬
+        """
+        print(f"[MAIN] ğŸ“Š ë°±í…ŒìŠ¤íŠ¸ ê²°ê³¼ UI ì—…ë°ì´íŠ¸: {symbol} -> {suitability} ({score}ì )")
+        self._update_backtest_status(symbol, suitability, score)
+    
+    def _on_backtest_failed(self, symbol: str, error: str):
+        """
+        ë°±í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨ ì²˜ë¦¬
+        
+        Args:
+            symbol: ì½”ì¸ ì‹¬ë³¼
+            error: ì—ëŸ¬ ë©”ì‹œì§€
+        """
+        print(f"[MAIN] âŒ ë°±í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨ UI ì—…ë°ì´íŠ¸: {symbol} -> {error}")
+        
+        # ìƒíƒœë¥¼ "ëŒ€ê¸°"ë¡œ ë³µì›
+        self._update_backtest_status(symbol, "ëŒ€ê¸°", 0)
+        
+        # ì‚¬ìš©ìì—ê²Œ ê²½ê³  ë©”ì‹œì§€
+        QMessageBox.warning(
+            self,
+            "ë°±í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨",
+            f"{symbol} ë°±í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨:\n{error}"
+        )
+    
+    # ========================================
+    # ì „ëµ ë¶„ì„ ê´€ë ¨ í•¸ë“¤ëŸ¬
+    # ========================================
+    
+    def _on_strategy_analysis_requested(self, symbol: str):
+        """
+        ì „ëµ ë¶„ì„ ìš”ì²­ ì²˜ë¦¬
+        
+        í”Œë¡œìš°:
+        1. íŒì—…ì°½ í‘œì‹œ (ë¡œë”© ì¸ë””ì¼€ì´í„°)
+        2. ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œì—ì„œ API í˜¸ì¶œ
+        3. ê²°ê³¼ ìˆ˜ì‹  ì‹œ íŒì—…ì°½ ì—…ë°ì´íŠ¸
+        
+        Args:
+            symbol: ì½”ì¸ ì‹¬ë³¼
+        """
+        print(f"[MAIN] ğŸ”¬ ì „ëµ ë¶„ì„ ìš”ì²­: {symbol}")
+
+        # íŒì—…ì°½ ìƒì„± (ë¡œë”© ìƒíƒœ)
+        dialog = StrategyAnalysisDialog(
+            symbol=symbol,
+            analysis_data={
+                "best_engine": "ë¶„ì„ì¤‘",
+                "volatility": 0,
+                "max_target_profit": {"alpha": 0, "beta": 0, "gamma": 0},
+                "risk_management": {"stop_loss": 0, "trailing_stop": 0},
+                "engine_results": {}
+            },
+            parent=self
+        )
+
+        # ì—”ì§„ ë°°ì¹˜ Signal ì—°ê²°
+        dialog.engine_assigned.connect(self._on_strategy_engine_assigned)
+
+        # íŒì—…ì°½ í‘œì‹œ (ë¹„ë™ê¸° ëª¨ë‹¬)
+        dialog.show()
+
+        # ë²„íŠ¼ ìƒíƒœ: ìš”ì²­ ì‹œì‘ (ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ LOADING -> RUNNING)
+        try:
+            # ì´ë¯¸ ë­í‚¹í…Œì´ë¸” ë²„íŠ¼ì€ í´ë¦­ ì‹œ LOADINGìœ¼ë¡œ ë°”ë€Œì§€ë§Œ
+            # ì•ˆì „í•˜ê²Œ RUNNING ìƒíƒœë¡œ ì „í™˜í•˜ì—¬ ì§„í–‰ì¤‘ í‘œê¸°ë¥¼ ë³´ì¥
+            self.ranking_table.set_analysis_state(symbol, AnalysisState.RUNNING)
+        except Exception:
+            pass
+
+        # ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì „ëµ ë¶„ì„ ì‹¤í–‰ (UI ë¸”ë¡œí‚¹ ë°©ì§€)
+        def worker():
+            try:
+                print(f"[MAIN] ğŸŒ ì „ëµ ë¶„ì„ API í˜¸ì¶œ: {symbol}")
+
+                # API í˜¸ì¶œ (íƒ€ì„ì•„ì›ƒ 60ì´ˆ - 3ê°œ ì—”ì§„ ë°±í…ŒìŠ¤íŒ…ì€ ì‹œê°„ ì†Œìš”)
+                response = requests.get(
+                    f"{BACKTEST_BASE_URL}/api/v1/backtest/strategy-analysis",
+                    params={"symbol": symbol, "period": "1w"},
+                    timeout=60
+                )
+
+                if response.ok:
+                    data = response.json().get("data", {})
+
+                    print(f"[MAIN] âœ… ì „ëµ ë¶„ì„ ì™„ë£Œ: {symbol} -> ì¶”ì²œ ì—”ì§„: {data.get('best_engine', 'Unknown')}")
+
+                    # íŒì—…ì°½ ì—…ë°ì´íŠ¸: ì›Œì»¤ ìŠ¤ë ˆë“œì—ì„œ ì§ì ‘ UIë¥¼ ì¡°ì‘í•˜ì§€ ì•Šê³ 
+                    # dialog.analysis_update ì‹œê·¸ë„ì„ emit í•˜ì—¬ ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ ì²˜ë¦¬í•˜ê²Œ í•¨
+                    try:
+                        dialog.analysis_update.emit(data)
+                    except Exception:
+                        # If direct emit failed (rare), schedule a queued emit on main thread
+                        try:
+                            QTimer.singleShot(0, lambda d=data: dialog.analysis_update.emit(d))
+                        except Exception:
+                            # as a last resort, set data for later
+                            dialog.analysis_data = data
+
+                    # ë²„íŠ¼ ìƒíƒœ: ì™„ë£Œ (ë§ˆìƒ¬ë§)
+                    try:
+                        QTimer.singleShot(0, lambda s=symbol: self.ranking_table.set_analysis_state(s, AnalysisState.COMPLETED))
+                    except Exception:
+                        pass
+                else:
+                    error = f"API ì˜¤ë¥˜ (status={response.status_code})"
+                    print(f"[MAIN] âŒ ì „ëµ ë¶„ì„ ì‹¤íŒ¨: {symbol} -> {error}")
+
+                    # ì—ëŸ¬ íŒì—… í‘œì‹œ
+                    QMessageBox.warning(
+                        self,
+                        "ì „ëµ ë¶„ì„ ì‹¤íŒ¨",
+                        f"{symbol} ì „ëµ ë¶„ì„ ì‹¤íŒ¨:\n{error}"
+                    )
+                    # ë²„íŠ¼ ìƒíƒœ: ì˜¤ë¥˜
+                    try:
+                        QTimer.singleShot(0, lambda s=symbol: self.ranking_table.set_analysis_state(s, AnalysisState.ERROR))
+                    except Exception:
+                        pass
+                    dialog.reject()  # íŒì—…ì°½ ë‹«ê¸°
+
+            except requests.Timeout:
+                error = "íƒ€ì„ì•„ì›ƒ (60ì´ˆ ì´ˆê³¼)"
+                print(f"[MAIN] â±ï¸ ì „ëµ ë¶„ì„ íƒ€ì„ì•„ì›ƒ: {symbol}")
+
+                QMessageBox.warning(
+                    self,
+                    "ì „ëµ ë¶„ì„ íƒ€ì„ì•„ì›ƒ",
+                    f"{symbol} ì „ëµ ë¶„ì„ ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤.\nì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."
+                )
+                dialog.reject()
+                try:
+                    QTimer.singleShot(0, lambda s=symbol: self.ranking_table.set_analysis_state(s, AnalysisState.ERROR))
+                except Exception:
+                    pass
+
+            except Exception as e:
+                error = str(e)
+                print(f"[MAIN] âŒ ì „ëµ ë¶„ì„ ì˜ˆì™¸: {symbol} -> {error}")
+
+                QMessageBox.warning(
+                    self,
+                    "ì „ëµ ë¶„ì„ ì˜¤ë¥˜",
+                    f"{symbol} ì „ëµ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:\n{error}"
+                )
+                dialog.reject()
+                try:
+                    QTimer.singleShot(0, lambda s=symbol: self.ranking_table.set_analysis_state(s, AnalysisState.ERROR))
+                except Exception:
+                    pass
+
+        # ë°ëª¬ ìŠ¤ë ˆë“œë¡œ ì‹¤í–‰ (GUI ë©”ì¸ ìŠ¤ë ˆë“œ ë¸”ë¡œí‚¹ ë°©ì§€)
+        threading.Thread(target=worker, daemon=True).start()
+    
+    def _on_strategy_engine_assigned(self, engine_name: str, strategy_data: dict):
+        """
+        ì „ëµ ë¶„ì„ í›„ ì—”ì§„ ë°°ì¹˜ ì²˜ë¦¬
+        
+        Args:
+            engine_name: ì—”ì§„ëª… ("Alpha", "Beta", "Gamma")
+            strategy_data: ì „ëµ ë°ì´í„° ë”•ì…”ë„ˆë¦¬
+        """
+        symbol = strategy_data.get("symbol")
+        analysis_data = strategy_data.get("analysis_data", {})
+
+        # ì¤‘ë³µ ë°°ì¹˜ ë°©ì§€: ë™ì¼ ì‹¬ë³¼ì´ ì´ë¯¸ ë‹¤ë¥¸ ì—”ì§„ì— ë°°ì¹˜ë˜ì–´ ìˆìœ¼ë©´ ê²½ê³  í›„ return
+        alpha_symbol = self.middle_session_widget.alpha_engine.selected_symbol
+        beta_symbol = self.middle_session_widget.beta_engine.selected_symbol
+        gamma_symbol = self.middle_session_widget.gamma_engine.selected_symbol
+        other_engines = []
+        if engine_name != "Alpha" and alpha_symbol == symbol:
+            other_engines.append("Alpha")
+        if engine_name != "Beta" and beta_symbol == symbol:
+            other_engines.append("Beta")
+        if engine_name != "Gamma" and gamma_symbol == symbol:
+            other_engines.append("Gamma")
+        if other_engines:
+            engine_list = ", ".join(other_engines)
+            from PySide6.QtWidgets import QMessageBox
+            QMessageBox.warning(
+                self,
+                "ì‹¬ë³¼ ì¤‘ë³µ ë°°ì¹˜ ë¶ˆê°€",
+                f"âš ï¸ ë™ì¼í•œ ì½”ì¸ì„ ì—¬ëŸ¬ ì—”ì§„ì— ë°°ì¹˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!\n\n"
+                f"ì„ íƒí•œ ì‹¬ë³¼: {symbol}\n"
+                f"ì´ë¯¸ ë°°ì¹˜ëœ ì—”ì§„: {engine_list}\n\n"
+                f"ë‹¤ë¥¸ ì½”ì¸ì„ ì„ íƒí•˜ê±°ë‚˜, {engine_list} ì—”ì§„ì—ì„œ\n"
+                f"í•´ë‹¹ ì‹¬ë³¼ì„ ë¨¼ì € ì œê±°í•œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”."
+            )
+            return
+
+        print(f"[MAIN] ğŸ¯ ì—”ì§„ ë°°ì¹˜: {symbol} -> {engine_name} ì—”ì§„")
+
+        # engine key (alpha/beta/gamma)
+        engine_key = engine_name.lower()
+        engine_results = analysis_data.get("engine_results", {}) if isinstance(analysis_data, dict) else {}
+        engine_result = engine_results.get(engine_key, {}) if isinstance(engine_results, dict) else {}
+
+        # ì¶”ì¶œ ê°€ëŠ¥í•œ ì‹¤í–‰ íŒŒë¼ë¯¸í„°
+        # ìš°ì„ : assign_payload(í•¨ìˆ˜ ì¸ì strategy_data) íƒ‘-ë ˆë²¨ì˜ executable_parameters ì‚¬ìš©
+        exec_params = {}
+        if isinstance(strategy_data, dict):
+            exec_params = strategy_data.get("executable_parameters") or {}
+        # í´ë°±: analysis_data.engine_results[engine_key].executable_parameters
+        if not exec_params:
+            if isinstance(engine_result, dict):
+                exec_params = engine_result.get("executable_parameters", {})
+
+        # ìµœëŒ€ ëª©í‘œ ìˆ˜ìµë¥ : analysis_dataì˜ mapping ìš°ì„ , ì—†ìœ¼ë©´ engine_result ë‚´ ê°’ ì‚¬ìš©
+        max_profit = analysis_data.get("max_target_profit", {}).get(engine_key,
+                                                                     engine_result.get("max_target_profit", 0) if isinstance(engine_result, dict) else 0)
+
+        # ë¦¬ìŠ¤í¬ ê´€ë¦¬
+        risk_mgmt = analysis_data.get("risk_management", {})
+
+        # í•˜ë‹¨ í‘¸í„°ì˜ í•´ë‹¹ ì—”ì§„ì— ì „ë‹¬ (exec_params í¬í•¨)
+        if engine_name == "Alpha":
+            self.middle_session_widget.alpha_engine.update_strategy_from_analysis(
+                symbol, max_profit, risk_mgmt, exec_params
+            )
+            self._focus_engine_tab("Alpha")
+        elif engine_name == "Beta":
+            self.middle_session_widget.beta_engine.update_strategy_from_analysis(
+                symbol, max_profit, risk_mgmt, exec_params
+            )
+            self._focus_engine_tab("Beta")
+        elif engine_name == "Gamma":
+            self.middle_session_widget.gamma_engine.update_strategy_from_analysis(
+                symbol, max_profit, risk_mgmt, exec_params
+            )
+            self._focus_engine_tab("Gamma")
+
+        # ë²„íŠ¼ ìƒíƒœ: ë¶„ì„ ì™„ë£Œë¡œ í‘œì‹œ
+        try:
+            QTimer.singleShot(0, lambda s=symbol: self.ranking_table.set_analysis_state(s, AnalysisState.COMPLETED))
+        except Exception:
+            pass
+
+        print(f"[MAIN] âœ… {engine_name} ì—”ì§„ ì „ëµ ì—…ë°ì´íŠ¸ ì™„ë£Œ: {symbol}")
+    
+    def _focus_engine_tab(self, engine_name: str):
+        """
+        í•´ë‹¹ ì—”ì§„ íƒ­ìœ¼ë¡œ í¬ì»¤ìŠ¤ ì´ë™
+        
+        Args:
+            engine_name: ì—”ì§„ëª… ("Alpha", "Beta", "Gamma")
+        """
+        # í‘¸í„° ìœ„ì ¯ì˜ í•´ë‹¹ ì—”ì§„ ìœ„ì ¯ ê°€ì ¸ì˜¤ê¸°
+        engine_widget = None
+        if engine_name == "Alpha":
+            engine_widget = self.middle_session_widget.alpha_engine
+        elif engine_name == "Beta":
+            engine_widget = self.middle_session_widget.beta_engine
+        elif engine_name == "Gamma":
+            engine_widget = self.middle_session_widget.gamma_engine
+        
+        if engine_widget:
+            # í•´ë‹¹ ì—”ì§„ ìœ„ì ¯ìœ¼ë¡œ í¬ì»¤ìŠ¤ ì´ë™
+            engine_widget.setFocus()
+            
+            # í•´ë‹¹ ì—”ì§„ ìœ„ì ¯ì´ ë³´ì´ë„ë¡ ìŠ¤í¬ë¡¤ ì´ë™ (ì„ íƒì‚¬í•­)
+            # parent_widget = engine_widget.parentWidget()
+            # if parent_widget:
+            #     parent_widget.ensureWidgetVisible(engine_widget)
+        
+        print(f"[MAIN] ğŸ¯ {engine_name} ì—”ì§„ìœ¼ë¡œ í¬ì»¤ìŠ¤ ì´ë™")
+
+
+if __name__ == '__main__':
+    app = QApplication(sys.argv)
+    window = YONAMainWindow()
+    window.show()
+    sys.exit(app.exec())
\ No newline at end of file
diff --git a/gui/widgets/strategy_analysis_dialog.py b/gui/widgets/strategy_analysis_dialog.py
new file mode 100644
index 0000000..00d2d81
--- /dev/null
+++ b/gui/widgets/strategy_analysis_dialog.py
@@ -0,0 +1,434 @@
+"""ì „ëµ ë¶„ì„ ê²°ê³¼ íŒì—…ì°½ ìœ„ì ¯"""
+from typing import Dict, Any, Optional
+from PySide6.QtWidgets import (
+    QDialog, QVBoxLayout, QHBoxLayout, QLabel,
+    QPushButton, QScrollArea, QWidget
+)
+from PySide6.QtWidgets import QCheckBox, QDialogButtonBox
+from PySide6.QtCore import Qt, Signal
+from PySide6.QtGui import QFont, QColor
+from datetime import datetime
+from PySide6.QtWidgets import QMessageBox
+
+
+class StrategyAnalysisDialog(QDialog):
+    """ì „ëµ ë¶„ì„ ê²°ê³¼ íŒì—…ì°½"""
+    
+    # Signal ì •ì˜
+    engine_assigned = Signal(str, dict)  # ì—”ì§„ ë°°ì¹˜ ì‹œ (engine_name, strategy_data)
+    analysis_update = Signal(dict)  # ì›Œì»¤ ìŠ¤ë ˆë“œì—ì„œ ì „ë‹¬ëœ ë¶„ì„ ê²°ê³¼ë¥¼ ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ ì²˜ë¦¬
+    
+    def __init__(self, symbol: str, analysis_data: dict, parent=None):
+        super().__init__(parent)
+        self.symbol = symbol
+        self.analysis_data = analysis_data
+        self.apply_risk_overrides = True
+        
+        self.setWindowTitle(f"ì „ëµ ë¶„ì„ ê²°ê³¼ - {symbol}")
+        self.setMinimumWidth(600)
+        self.setMinimumHeight(600)
+        
+        # ë‹¤ì´ì–¼ë¡œê·¸ ìŠ¤íƒ€ì¼
+        self.setStyleSheet("""
+            QDialog {
+                background-color: #1e1e1e;
+                color: #ffffff;
+            }
+            QLabel {
+                color: #ffffff;
+            }
+        """)
+        
+        # build initial UI (on main thread)
+        self._init_ui()
+        # connect update signal to slot to safely update UI from worker threads
+        # use queued connection to ensure handler runs on main thread when emitted from worker
+        try:
+            self.analysis_update.connect(self._on_analysis_update, Qt.QueuedConnection)
+        except Exception:
+            # fallback if connection with explicit type is not supported
+            self.analysis_update.connect(self._on_analysis_update)
+
+    def _on_analysis_update(self, data: dict):
+        """Slot: update analysis data and refresh UI in main thread"""
+        try:
+            self.analysis_data = data
+            # Rebuild UI on main thread
+            self._init_ui()
+        except Exception:
+            # avoid raising UI exceptions from the slot
+            pass
+    
+    def _init_ui(self):
+        # If there's an existing layout (e.g. when updating), clear it
+        old_layout = self.layout()
+        if old_layout is not None:
+            try:
+                self._clear_layout(old_layout)
+            except Exception:
+                # best-effort: ignore UI cleanup errors
+                pass
+
+        layout = QVBoxLayout(self)
+        layout.setSpacing(10)
+        layout.setContentsMargins(15, 15, 15, 15)
+        
+        # 1. í—¤ë”
+        header = QLabel(f"ì „ëµ ë¶„ì„ ê²°ê³¼: {self.symbol}")
+        header_font = QFont()
+        header_font.setBold(True)
+        header_font.setPointSize(14)
+        header.setFont(header_font)
+        header.setStyleSheet("color: #FFC107;")
+        layout.addWidget(header)
+        # --- ì‹ ê·œìƒì¥ ë°°ë„ˆ ë° ì‹ ë¢°ë„ í‘œì‹œ ---
+        try:
+            engine_results = self.analysis_data.get("engine_results", {})
+            # is_new_listing / data_missing íŒë‹¨: top-level ìš°ì„ , ì—†ìœ¼ë©´ ì—”ì§„ë³„ OR
+            is_new = bool(self.analysis_data.get("is_new_listing") or any(
+                (engine.get("is_new_listing") is True) for engine in engine_results.values()
+            ))
+            data_missing = bool(self.analysis_data.get("data_missing") or any(
+                (engine.get("data_missing") is True) for engine in engine_results.values()
+            ))
+
+            # ì „ë°˜ì  confidence ê³„ì‚°: top-level > heuristic.confidence > engine confidence max
+            conf = None
+            if isinstance(self.analysis_data.get("confidence"), (int, float)):
+                conf = float(self.analysis_data.get("confidence"))
+            elif isinstance(self.analysis_data.get("heuristic"), dict) and isinstance(self.analysis_data.get("heuristic").get("confidence"), (int, float)):
+                conf = float(self.analysis_data.get("heuristic").get("confidence"))
+            else:
+                try:
+                    conf = max(float(engine.get("confidence", 0)) for engine in engine_results.values()) if engine_results else None
+                except Exception:
+                    conf = None
+
+            if is_new or data_missing:
+                banner = QLabel()
+                if is_new and data_missing:
+                    banner.setText("ğŸ”” ì‹ ê·œ ìƒì¥ ì½”ì¸ (ë°ì´í„° ë¶€ì¡±) â€” ë³´ìˆ˜ì  ì„¤ì • ê¶Œì¥")
+                    banner.setStyleSheet('background-color: #FFA000; color: #1b1b1b; padding: 6px; border-radius:4px;')
+                elif is_new:
+                    banner.setText("ğŸ”” ì‹ ê·œ ìƒì¥ ì½”ì¸ â€” ì‹ ê·œìƒì¥ ì „ìš© ì „ëµ ì ìš©")
+                    banner.setStyleSheet('background-color: #FFF176; color: #1b1b1b; padding: 6px; border-radius:4px;')
+                else:
+                    banner.setText("âš ï¸ ë°ì´í„° ë¶€ì¡± â€” ë³´ìˆ˜ì  ì„¤ì • ì‚¬ìš©")
+                    banner.setStyleSheet('background-color: #FFE0B2; color: #1b1b1b; padding: 6px; border-radius:4px;')
+                layout.addWidget(banner)
+
+            # confidence í‘œì‹œ
+            if conf is not None:
+                try:
+                    conf_pct = float(conf) * 100.0 if conf <= 1.0 else float(conf)
+                except Exception:
+                    conf_pct = float(conf)
+                conf_label = QLabel(f"ì‹ ë¢°ë„: {conf_pct:.1f}%")
+                # ìƒ‰ìƒ: ë†’ì„ìˆ˜ë¡ ë…¹ìƒ‰, ë‚®ì„ìˆ˜ë¡ ë¹¨ê°•
+                if conf_pct >= 75:
+                    c_style = "color: #4CAF50; font-weight: bold;"
+                elif conf_pct >= 40:
+                    c_style = "color: #FFC107;"
+                else:
+                    c_style = "color: #F44336;"
+                conf_label.setStyleSheet(c_style + " font-size: 11px;")
+                layout.addWidget(conf_label)
+        except Exception:
+            # ì•ˆì „ë§: UI ë¹Œë“œ ì‹¤íŒ¨ ì‹œ ë¬´ì‹œ
+            pass
+        
+        # 2. ì¶”ì²œ ì—”ì§„
+        best_engine = self.analysis_data.get("best_engine", "Alpha")
+        recommendation = QLabel(f"âœ… ì¶”ì²œ ì—”ì§„: {best_engine}")
+        recommendation.setStyleSheet("color: #4CAF50; font-weight: bold; font-size: 12px;")
+        layout.addWidget(recommendation)
+        
+        # 3. ë³€ë™ì„± ì •ë³´
+        volatility = self.analysis_data.get("volatility", 0)
+        volatility_label = QLabel(f"ğŸ“Š ë³€ë™ì„±: {volatility:.2f}%")
+        volatility_label.setStyleSheet("color: #FFC107; font-size: 11px;")
+        layout.addWidget(volatility_label)
+        
+        # 4. ìŠ¤í¬ë¡¤ ì˜ì—­ (ìƒì„¸ ì •ë³´)
+        scroll_area = QScrollArea()
+        scroll_area.setWidgetResizable(True)
+        scroll_area.setStyleSheet("""
+            QScrollArea {
+                border: 1px solid #333333;
+                border-radius: 5px;
+                background-color: #2a2a2a;
+            }
+        """)
+        
+        scroll_widget = QWidget()
+        scroll_layout = QVBoxLayout(scroll_widget)
+        scroll_layout.setSpacing(10)
+        scroll_layout.setContentsMargins(10, 10, 10, 10)
+        
+        
+        
+        # 4-1. í†µí•© ì „ëµ ìš”ì•½: metrics + single executable_parameters
+        metrics = self.analysis_data.get("metrics", {})
+        metrics_text = (
+            f"ì´ ìˆ˜ìµë¥ : {metrics.get('total_return_pct', 0):.2f}%\n"
+            f"ìŠ¹ë¥ : {metrics.get('win_rate', 0):.2f}%\n"
+            f"ìµœëŒ€ ë‚™í­: {metrics.get('max_drawdown_pct', 0):.2f}%\n"
+            f"ë³€ë™ì„±: {metrics.get('volatility_pct', 0):.2f}%"
+        )
+        metrics_section = self._create_section("ğŸ“ˆ ì „ëµ ìš”ì•½", metrics_text)
+        scroll_layout.addWidget(metrics_section)
+
+        # 4-2. íŒŒë¼ë¯¸í„° ê°œìš” (human-friendly)
+        exec_params = self.analysis_data.get('executable_parameters', {}) or {}
+        overview_lines = []
+        lev = exec_params.get('leverage')
+        ps = exec_params.get('position_size')
+        sl = exec_params.get('stop_loss_pct')
+        no_comp = exec_params.get('no_compounding')
+        overview_lines.append(f"ê¶Œì¥ ë ˆë²„ë¦¬ì§€: {int(lev) if lev is not None else 'N/A'}x")
+        if isinstance(ps, float) and ps <= 1:
+            overview_lines.append(f"ê±°ë˜ë‹¹ ìë³¸ ë¹„ì¤‘: {ps*100:.2f}%")
+        else:
+            overview_lines.append(f"ê±°ë˜ë‹¹ ìë³¸ ë¹„ì¤‘: {ps if ps is not None else 'N/A'}")
+        overview_lines.append(f"ì „ëµ ê¶Œì¥ ì†ì ˆ: {float(sl)*100:.2f}%" if sl is not None else "ì „ëµ ê¶Œì¥ ì†ì ˆ: N/A")
+        overview_lines.append(f"ë³µë¦¬: {'í™œì„±(ì „ëµ ê¸°ë³¸)' if no_comp is not True else 'ë¹„í™œì„±(ë³µë¦¬ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ)'}")
+        overview_section = self._create_section("ğŸ§¾ íŒŒë¼ë¯¸í„° ê°œìš”", "\n".join(overview_lines))
+        scroll_layout.addWidget(overview_section)
+
+        # 4-3. ìƒì„¸ íŒŒë¼ë¯¸í„° í…Œì´ë¸” (simple label list)
+        try:
+            params_widget = QWidget()
+            params_layout = QVBoxLayout(params_widget)
+            params_layout.setContentsMargins(0,0,0,0)
+            params_layout.setSpacing(4)
+            if exec_params:
+                for k, v in exec_params.items():
+                    display_val = v
+                    if k.endswith('_pct') and isinstance(v, float):
+                        display_val = f"{v*100:.2f}%"
+                    elif k == 'position_size' and isinstance(v, float) and v <= 1:
+                        display_val = f"{v*100:.2f}%"
+                    params_layout.addWidget(QLabel(f"{k}: {display_val}"))
+            else:
+                params_layout.addWidget(QLabel("íŒŒë¼ë¯¸í„° ì—†ìŒ"))
+            scroll_layout.addWidget(self._create_section("ğŸ”§ ìƒì„¸ íŒŒë¼ë¯¸í„°", ""))
+            scroll_layout.addWidget(params_widget)
+        except Exception:
+            pass
+
+        scroll_layout.addStretch()
+        scroll_area.setWidget(scroll_widget)
+        layout.addWidget(scroll_area)
+        
+        
+        # (í•˜ë‹¨ ì•¡ì…˜ ì˜ì—­ì€ ì•„ë˜ì—ì„œ êµ¬ì„±)
+
+        action_container = QWidget()
+        action_layout = QHBoxLayout(action_container)
+        action_layout.setSpacing(10)
+        action_layout.setContentsMargins(0, 10, 0, 0)
+
+        # Apply risk overrides checkbox
+        self.risk_override_checkbox = QCheckBox("Apply risk overrides (ê¶Œì¥)")
+        self.risk_override_checkbox.setChecked(True if self.apply_risk_overrides else False)
+        action_layout.addWidget(self.risk_override_checkbox)
+
+        action_layout.addStretch()
+
+        assign_label = QLabel("Assign Trading Symbol:")
+        assign_label.setStyleSheet("font-weight: bold; font-size: 11px; color: #999;")
+        action_layout.addWidget(assign_label)
+
+        engines = [
+            ("Alpha", "#4CAF50", "ALPHA"),
+            ("Beta", "#2196F3", "BETA"),
+            ("Gamma", "#FF9800", "GAMMA")
+        ]
+
+        for engine_name, color, label in engines:
+            btn = QPushButton(label)
+            btn.setStyleSheet(f"""
+                QPushButton {{
+                    background-color: {color};
+                    color: white;
+                    font-weight: bold;
+                    font-size: 11px;
+                    border: none;
+                    border-radius: 3px;
+                    padding: 6px 15px;
+                    min-width: 60px;
+                }}
+                QPushButton:hover {{
+                    background-color: {self._lighten_color(color)};
+                }}
+                QPushButton:pressed {{
+                    background-color: {self._darken_color(color)};
+                }}
+            """)
+
+            btn.clicked.connect(lambda checked, e=engine_name: self._preview_and_assign(e))
+            action_layout.addWidget(btn)
+
+        cancel_btn = QPushButton("Cancel")
+        cancel_btn.clicked.connect(self.reject)
+        action_layout.addWidget(cancel_btn)
+
+        layout.addWidget(action_container)
+
+    def _clear_layout(self, layout):
+        """Recursively clear and delete a QLayout and its child widgets/layouts.
+
+        This removes widgets from their parents and calls deleteLater on layouts
+        to avoid 'QLayout: Attempting to add QLayout' warnings when rebuilding UI.
+        """
+        if layout is None:
+            return
+
+        # Remove all items
+        while layout.count():
+            item = layout.takeAt(0)
+            if item is None:
+                continue
+            widget = item.widget()
+            if widget is not None:
+                try:
+                    widget.setParent(None)
+                    widget.deleteLater()
+                except Exception:
+                    pass
+            else:
+                child_layout = item.layout()
+                if child_layout is not None:
+                    # recursive clear
+                    try:
+                        self._clear_layout(child_layout)
+                    except Exception:
+                        pass
+
+        # schedule layout for deletion
+        try:
+            layout.deleteLater()
+        except Exception:
+            pass
+    
+    def _create_section(self, title: str, content: str) -> QWidget:
+        """ì„¹ì…˜ ìœ„ì ¯ ìƒì„±"""
+        widget = QWidget()
+        layout = QVBoxLayout(widget)
+        layout.setContentsMargins(0, 0, 0, 0)
+        layout.setSpacing(5)
+        
+        title_label = QLabel(title)
+        title_label.setStyleSheet("font-weight: bold; font-size: 11px; color: #FFC107;")
+        layout.addWidget(title_label)
+        
+        content_label = QLabel(content)
+        content_label.setStyleSheet("font-size: 10px; color: #CCCCCC;")
+        content_label.setWordWrap(True)
+        layout.addWidget(content_label)
+        
+        return widget
+    
+    def _create_engine_section(self, engine_name: str, engine_data: dict) -> QWidget:
+        """ë ˆê±°ì‹œ: ì—”ì§„ë³„ ìƒì„¸ ì„¹ì…˜ ìƒì„±ê¸° (ì œê±°ë¨).
+
+        ì´ í•¨ìˆ˜ëŠ” í˜„ì¬ ì½”ë“œ ê²½ë¡œì—ì„œ í˜¸ì¶œë˜ì§€ ì•Šìœ¼ë©°, ìœ ì§€ë³´ìˆ˜ ë¶€ë‹´ì„
+        ì¤„ì´ê¸° ìœ„í•´ ì œê±° ìƒíƒœë¡œ í‘œì‹œí•©ë‹ˆë‹¤. í•„ìš” ì‹œ Git ì´ë ¥ì—ì„œ ë³µì›í•˜ì„¸ìš”.
+        """
+        raise NotImplementedError("_create_engine_section() has been removed; see git history for prior implementation")
+    
+    def _lighten_color(self, color: str) -> str:
+        """ìƒ‰ìƒ ë°ê²Œ"""
+        color_map = {
+            "#4CAF50": "#66BB6A",  # Alpha
+            "#2196F3": "#42A5F5",  # Beta
+            "#FF9800": "#FFB74D"   # Gamma
+        }
+        return color_map.get(color, color)
+    
+    def _darken_color(self, color: str) -> str:
+        """ìƒ‰ìƒ ì–´ë‘¡ê²Œ"""
+        color_map = {
+            "#4CAF50": "#388E3C",  # Alpha
+            "#2196F3": "#1976D2",  # Beta
+            "#FF9800": "#F57C00"   # Gamma
+        }
+        return color_map.get(color, color)
+    
+    def _preview_and_assign(self, engine_name: str):
+        """Show preview modal with final params and emit assign_payload on confirmation."""
+        # Start from unified executable_parameters
+        base_params = self.analysis_data.get('executable_parameters', {}) or {}
+        final_params = dict(base_params)  # shallow copy
+
+        applied_overrides = {}
+        if getattr(self, 'risk_override_checkbox', None) and self.risk_override_checkbox.isChecked():
+            # Apply risk management suggestions (if present) into final params
+            rm = self.analysis_data.get('risk_management', {}) or {}
+            # map known keys
+            if 'stop_loss' in rm:
+                final_params['stop_loss_pct'] = float(rm.get('stop_loss'))
+                applied_overrides['stop_loss_pct'] = final_params['stop_loss_pct']
+            if 'trailing_stop' in rm:
+                final_params['trailing_stop_pct'] = float(rm.get('trailing_stop'))
+                applied_overrides['trailing_stop_pct'] = final_params['trailing_stop_pct']
+            # if backend marks new listing, we may suggest lower leverage via risk_management or presets
+            if self.analysis_data.get('is_new_listing') and 'force_leverage' in rm:
+                final_params['leverage'] = int(rm.get('force_leverage'))
+                applied_overrides['force_leverage'] = final_params['leverage']
+
+        # Build assign payload
+        assign_payload = {
+            'symbol': self.symbol,
+            'engine_name': engine_name,
+            'analysis_data': self.analysis_data,
+            'executable_parameters': final_params,
+            'applied_risk_overrides': applied_overrides,
+            'ui_meta': {
+                'confirmed_by_user': False,
+                'confirmed_at': None,
+                'source': 'strategy_analysis_dialog_v2'
+            }
+
+        }
+
+
+        # Prepare preview text
+        def param_line(k, v):
+            if k.endswith('_pct') and isinstance(v, float):
+                return f"{k}: {v*100:.2f}%"
+            if k == 'position_size' and isinstance(v, float) and v <= 1:
+                return f"{k}: {v*100:.2f}%"
+            return f"{k}: {v}"
+
+        lines = [f"Symbol: {self.symbol}", f"Engine: {engine_name}", "", "Final Parameters:"]
+        for k, v in final_params.items():
+            lines.append(param_line(k, v))
+        if applied_overrides:
+            lines.append("")
+            lines.append("Applied Risk Overrides:")
+            for k, v in applied_overrides.items():
+                lines.append(param_line(k, v))
+
+        preview_text = "\n".join(lines)
+
+        # Show confirmation dialog
+        msg = QMessageBox(self)
+        msg.setWindowTitle("Assign Preview")
+        msg.setText("Assign the following strategy parameters to %s?" % engine_name)
+        msg.setDetailedText(preview_text)
+        msg.setStandardButtons(QMessageBox.Cancel | QMessageBox.Ok)
+        msg.setDefaultButton(QMessageBox.Ok)
+        ret = msg.exec()
+        if ret == QMessageBox.Ok:
+            assign_payload['ui_meta']['confirmed_by_user'] = True
+            assign_payload['ui_meta']['confirmed_at'] = datetime.utcnow().isoformat() + 'Z'
+            # emit signal to main
+            try:
+                self.engine_assigned.emit(engine_name, assign_payload)
+            except Exception:
+                pass
+            # close dialog
+            self.accept()
+
+
diff --git a/scripts/gui_assign_test.py b/scripts/gui_assign_test.py
new file mode 100644
index 0000000..3c3c309
--- /dev/null
+++ b/scripts/gui_assign_test.py
@@ -0,0 +1,134 @@
+import sys
+import os
+import urllib.request
+import json
+from PySide6.QtWidgets import QApplication
+
+# ensure project root is in sys.path
+ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+if ROOT not in sys.path:
+    sys.path.insert(0, ROOT)
+
+from gui.widgets.strategy_analysis_dialog import StrategyAnalysisDialog
+from gui.widgets.footer_engines_widget import TradingEngineWidget
+
+
+def fetch_analysis(symbol='SQDUSDT'):
+    url = f'http://127.0.0.1:8001/api/v1/backtest/strategy-analysis?symbol={symbol}&period=1w&interval=1h'
+    try:
+        with urllib.request.urlopen(url, timeout=10) as r:
+            return json.load(r).get('data', {})
+    except Exception as e:
+        # fallback: load last captured analysis (offline test)
+        print('[TEST] Backend fetch failed, falling back to local capture:', e)
+        local_path = os.path.join(os.path.dirname(__file__), 'find_new_listing_report.json')
+        if os.path.exists(local_path):
+            with open(local_path, 'r', encoding='utf-8') as f:
+                payload = json.load(f)
+                return payload.get('out', {}).get('data', payload.get('data', {}))
+        raise
+
+
+def main():
+    app = QApplication([])
+    print('[TEST] Fetching analysis from backend...')
+    data = fetch_analysis()
+    print('[TEST] Received analysis keys:', list(data.keys()))
+
+    # If backend/local capture returned no useful data, create a synthetic minimal payload
+    if not data:
+        print('[TEST] No analysis data found - using synthetic sample payload for GUI test')
+        data = {
+            'symbol': 'SQDUSDT',
+            'best_engine': 'Alpha',
+            'volatility': 12.3,
+            'max_target_profit': {'alpha': 3.5, 'beta': 4.2, 'gamma': 6.0},
+            'risk_management': {'stop_loss': 0.2, 'trailing_stop': 0.1},
+            'is_new_listing': True,
+            'data_missing': False,
+            'confidence': 0.78,
+            'engine_results': {
+                'alpha': {
+                    'suitability': 'ì í•©',
+                    'score': 92,
+                    'expected_profit': 3.2,
+                    'max_target_profit': 3.5,
+                    'win_rate': 62.5,
+                    'executable_parameters': {
+                        'fast_ema_period': 5,
+                        'slow_ema_period': 21,
+                        'stop_loss_pct': 0.02,
+                        'leverage': 1,
+                        'position_size': 0.02
+                    },
+                    'is_new_listing': True,
+                    'data_missing': False,
+                    'confidence': 0.8
+                },
+                'beta': {},
+                'gamma': {}
+            }
+        }
+
+    # Create dialog with placeholder then update
+    dialog = StrategyAnalysisDialog(symbol=data.get('symbol','SQDUSDT'), analysis_data={
+        'best_engine':'loading', 'volatility':0, 'max_target_profit':{}, 'risk_management':{}, 'engine_results':{}
+    })
+
+    # Connect engine_assigned to capture
+    assigned = {}
+    def on_assigned(engine_name, strategy_data):
+        print('[TEST] engine_assigned emitted ->', engine_name)
+        assigned['engine'] = engine_name
+        assigned['strategy_data'] = strategy_data
+
+    dialog.engine_assigned.connect(on_assigned)
+
+    # Update dialog with real data via signal (mimic worker)
+    dialog.analysis_update.emit(data)
+
+    # Check rendered content by inspecting dialog.analysis_data
+    print('[TEST] dialog.analysis_data keys:', list(dialog.analysis_data.keys()))
+    engine_results = dialog.analysis_data.get('engine_results', {})
+    for e in ['alpha','beta','gamma']:
+        er = engine_results.get(e, {})
+        execp = er.get('executable_parameters')
+        print(f'[TEST] engine={e} has executable_parameters? {bool(execp)}')
+        if execp:
+            # Pretty print some fields
+            print('  sample:', {k: execp.get(k) for k in ('fast_ema_period','slow_ema_period','stop_loss_pct','leverage','position_size')})
+
+    # Simulate clicking Assign for Alpha by emitting a headless-friendly payload
+    print('[TEST] Simulating Assign (Alpha) via simulated payload')
+    simulated_payload = {
+        'symbol': data.get('symbol','SQDUSDT'),
+        'engine_name': 'Alpha',
+        'analysis_data': data,
+        'executable_parameters': data.get('engine_results', {}).get('alpha', {}).get('executable_parameters', {}),
+        'applied_risk_overrides': {},
+        'ui_meta': {'confirmed_by_user': True, 'confirmed_at': None, 'source': 'tests/gui_assign_test'}
+    }
+    dialog.engine_assigned.emit('Alpha', simulated_payload)
+
+    print('[TEST] Assigned payload:', assigned.keys())
+    if assigned:
+        sd = assigned.get('strategy_data',{})
+        ad = sd.get('analysis_data',{})
+        alpha_exec = ad.get('engine_results',{}).get('alpha',{}).get('executable_parameters')
+        print('[TEST] extracted alpha executable:', alpha_exec)
+
+    # Create engine widget and apply params
+    engine_widget = TradingEngineWidget('Alpha','#4CAF50')
+    print('[TEST] Before apply - leverage slider value:', engine_widget.leverage_slider.value(), engine_widget.leverage_value_label.text())
+    print('[TEST] Before apply - funds slider value:', engine_widget.funds_slider.value(), engine_widget.funds_value_label.text())
+
+    if alpha_exec:
+        engine_widget.update_strategy_from_analysis(data.get('symbol','SQDUSDT'), data.get('max_target_profit',{}).get('alpha',0), data.get('risk_management',{}), alpha_exec)
+        print('[TEST] After apply - leverage slider value:', engine_widget.leverage_slider.value(), engine_widget.leverage_value_label.text())
+        print('[TEST] After apply - funds slider value:', engine_widget.funds_slider.value(), engine_widget.funds_value_label.text())
+
+    print('[TEST] Done')
+    # don't exec app.exec() - this is headless test
+
+if __name__ == '__main__':
+    main()
-- 
2.51.0.windows.1

